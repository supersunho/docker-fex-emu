name: Universal Automation Dashboard

on:
    # schedule:
    #     # Allow cron schedule to be set via Variables (default provided)
    #     - cron: "*/30 * * * *"

    workflow_run:
        workflows: ["*"]
        types: [completed, requested]

    workflow_dispatch:
        inputs:
            force_refresh:
                description: "Force refresh all dashboard data"
                required: false
                default: false
                type: boolean

permissions:
    contents: read
    issues: write
    actions: read
env:
    # ðŸ“Š PROJECT CONFIGURATION
    PROJECT_DISPLAY_NAME: ${{ github.repository }}
    PROJECT_DESCRIPTION: ""

    # ðŸ³ DOCKER CONFIGURATION
    DOCKER_USERNAME: ${{ github.repository_owner }}
    DOCKER_REPOSITORY: ${{ github.event.repository.name }}

    # âš¡ HEALTH MONITORING
    HEALTH_WARNING_THRESHOLD: "90"
    HEALTH_CRITICAL_THRESHOLD: "95"
    HISTORY_DAYS: "30"

    # ðŸ”” NOTIFICATIONS
    ENABLE_HEALTH_ALERTS: "true"
    ENABLE_SLACK_NOTIFICATIONS: "false"
    ENABLE_TEAMS_NOTIFICATIONS: "false"
    ENABLE_DISCORD_NOTIFICATIONS: "false"

    # ðŸ“ˆ EXTERNAL MONITORING
    ENABLE_EXTERNAL_MONITORING: "false"
    ENABLE_PROMETHEUS_INTEGRATION: "false"
    ENABLE_GRAFANA_INTEGRATION: "false"
    ENABLE_CUSTOM_WEBHOOK_INTEGRATION: "false"

    # âš™ï¸ SYSTEM CONFIGURATION
    MONITORING_LABELS: "automation,ci,build,deploy"
    DASHBOARD_SCHEDULE: "*/30 * * * *"

jobs:
    load-configuration:
        runs-on: ubuntu-latest
        outputs:
            docker_repo: ${{ steps.config.outputs.docker_repo }}
            health_thresholds: ${{ steps.config.outputs.health_thresholds }}
            monitoring_config: ${{ steps.config.outputs.monitoring_config }}
            notification_config: ${{ steps.config.outputs.notification_config }}
            external_monitoring_config: ${{ steps.config.outputs.external_monitoring_config }}

        steps:
            - name: Load project configuration from Variables and Secrets
              id: config
              uses: actions/github-script@v7
              with:
                  script: |
                      console.log('ðŸ”§ Loading project configuration from GitHub Variables and Secrets...');

                      // Load configuration from GitHub Variables
                      const config = {
                          // Docker configuration (Variables)
                          docker_username: '${{ env.DOCKER_USERNAME }}' || '${{ github.repository_owner }}',
                          docker_repo: '${{ env.DOCKER_USERNAME }}/${{ env.DOCKER_REPOSITORY }}' ||
                                      '${{ github.repository_owner }}/${{ github.event.repository.name }}',
                          
                          // Health status thresholds (Variables)
                          health_warning_threshold: '${{ env.HEALTH_WARNING_THRESHOLD }}' || '90',
                          health_critical_threshold: '${{ env.HEALTH_CRITICAL_THRESHOLD }}' || '95',
                          
                          // Monitoring configuration (Variables)
                          monitoring_labels: '${{ env.MONITORING_LABELS }}' || 'automation,ci,build,deploy',
                          dashboard_update_frequency: '*/30 * * * *',
                          history_days: '${{ env.HISTORY_DAYS }}' || '30',
                          
                          // Notification settings (Variables)
                          enable_health_alerts: '${{ env.ENABLE_HEALTH_ALERTS }}' || 'true',
                          enable_slack_notifications: '${{ env.ENABLE_SLACK_NOTIFICATIONS }}' || 'false',
                          enable_teams_notifications: '${{ env.ENABLE_TEAMS_NOTIFICATIONS }}' || 'false',
                          enable_discord_notifications: '${{ env.ENABLE_DISCORD_NOTIFICATIONS }}' || 'false',
                          
                          // External monitoring service-specific settings (Variables) - Datadog removed
                          enable_external_monitoring: '${{ env.ENABLE_EXTERNAL_MONITORING }}' || 'false',
                          enable_prometheus_integration: '${{ env.ENABLE_PROMETHEUS_INTEGRATION }}' || 'false',
                          enable_grafana_integration: '${{ env.ENABLE_GRAFANA_INTEGRATION }}' || 'false',
                          enable_custom_webhook_integration: '${{ env.ENABLE_CUSTOM_WEBHOOK_INTEGRATION }}' || 'false',
                          
                          // Project metadata (Variables)
                          project_display_name: '${{ env.PROJECT_DISPLAY_NAME }}' || '${{ github.repository }}',
                          project_description: '${{ env.PROJECT_DESCRIPTION }}' || 'Automated project monitoring'
                      };

                      console.log('ðŸ“‹ Loaded configuration:');
                      console.log(`  - Docker Repo: ${config.docker_repo}`);
                      console.log(`  - Health Thresholds: Warning ${config.health_warning_threshold}%, Critical ${config.health_critical_threshold}%`);
                      console.log(`  - Monitoring Labels: ${config.monitoring_labels}`);
                      console.log(`  - Update Frequency: ${config.dashboard_update_frequency}`);
                      console.log(`  - Health Alerts: ${config.enable_health_alerts}`);
                      console.log(`  - Slack Notifications: ${config.enable_slack_notifications}`);
                      console.log(`  - Teams Notifications: ${config.enable_teams_notifications}`);
                      console.log(`  - Discord Notifications: ${config.enable_discord_notifications}`);
                      console.log(`  - External Monitoring Master: ${config.enable_external_monitoring}`);
                      console.log(`  - Prometheus Integration: ${config.enable_prometheus_integration}`);
                      console.log(`  - Grafana Integration: ${config.enable_grafana_integration}`);
                      console.log(`  - Custom Webhook Integration: ${config.enable_custom_webhook_integration}`);

                      // Configuration validation
                      const healthThresholds = {
                          warning: parseInt(config.health_warning_threshold),
                          critical: parseInt(config.health_critical_threshold)
                      };

                      if (healthThresholds.warning >= healthThresholds.critical) {
                          console.log('âš ï¸ Warning: Health warning threshold should be lower than critical threshold');
                          healthThresholds.warning = healthThresholds.critical - 5;
                      }

                      const monitoringConfig = {
                          labels: config.monitoring_labels.split(',').map(l => l.trim()),
                          history_days: parseInt(config.history_days),
                          update_frequency: config.dashboard_update_frequency
                      };

                      const notificationConfig = {
                          health_alerts: config.enable_health_alerts === 'true',
                          slack_notifications: config.enable_slack_notifications === 'true',
                          teams_notifications: config.enable_teams_notifications === 'true',
                          discord_notifications: config.enable_discord_notifications === 'true',
                          external_monitoring: config.enable_external_monitoring === 'true'
                      };

                      // External monitoring service-specific configuration (Datadog removed)
                      const externalMonitoringConfig = {
                          master_enable: config.enable_external_monitoring === 'true',
                          prometheus: config.enable_prometheus_integration === 'true',
                          grafana: config.enable_grafana_integration === 'true',
                          custom_webhook: config.enable_custom_webhook_integration === 'true'
                      };

                      // Set outputs
                      core.setOutput('docker_repo', config.docker_repo);
                      core.setOutput('health_thresholds', JSON.stringify(healthThresholds));
                      core.setOutput('monitoring_config', JSON.stringify(monitoringConfig));
                      core.setOutput('notification_config', JSON.stringify(notificationConfig));
                      core.setOutput('external_monitoring_config', JSON.stringify(externalMonitoringConfig));

                      return config;

    collect-metrics:
        needs: load-configuration
        runs-on: ubuntu-latest
        outputs:
            dashboard_data: ${{ steps.compile_data.outputs.dashboard_json }}
            last_updated: ${{ steps.compile_data.outputs.last_updated }}
            system_health: ${{ steps.compile_data.outputs.system_health }}

        steps:
            - name: Checkout repository
              uses: actions/checkout@v4

            - name: Auto-discover workflows with configurable settings
              id: discover_workflows
              uses: actions/github-script@v7
              with:
                  script: |
                      const monitoringConfig = JSON.parse('${{ needs.load-configuration.outputs.monitoring_config }}');

                      console.log(`ðŸ” Auto-discovering workflows with ${monitoringConfig.history_days} days history...`);

                      const historyDate = new Date();
                      historyDate.setDate(historyDate.getDate() - monitoringConfig.history_days);

                      // Get all workflows in repository
                      const workflowsResponse = await github.rest.actions.listRepoWorkflows({
                          owner: context.repo.owner,
                          repo: context.repo.repo
                      });

                      const allWorkflows = workflowsResponse.data.workflows;
                      console.log(`ðŸ“‹ Found ${allWorkflows.length} workflows in repository`);

                      // Auto-categorize workflows based on patterns
                      const workflowCategories = {
                          'build': [],
                          'test': [],
                          'deploy': [],
                          'automation': [],
                          'security': [],
                          'maintenance': [],
                          'other': []
                      };

                      let totalRuns = 0;
                      let successfulRuns = 0;
                      let failedRuns = 0;
                      let averageDuration = 0;
                      let recentBuilds = [];

                      for (const workflow of allWorkflows) {
                          const name = workflow.name.toLowerCase();
                          const path = workflow.path.toLowerCase();

                          console.log(`ðŸ” Analyzing workflow: ${workflow.name}`);

                          // Smart categorization
                          let category = 'other';
                          if (name.includes('build') || name.includes('compile') || name.includes('make')) {
                              category = 'build';
                          } else if (name.includes('test') || name.includes('spec') || name.includes('lint')) {
                              category = 'test';
                          } else if (name.includes('deploy') || name.includes('release') || name.includes('publish')) {
                              category = 'deploy';
                          } else if (name.includes('auto') || name.includes('schedule') || name.includes('cron')) {
                              category = 'automation';
                          } else if (name.includes('security') || name.includes('scan') || name.includes('audit')) {
                              category = 'security';
                          } else if (name.includes('cleanup') || name.includes('maintenance') || name.includes('update')) {
                              category = 'maintenance';
                          }

                          workflowCategories[category].push({
                              ...workflow,
                              category: category
                          });

                          // Get workflow runs for statistics
                          try {
                              const runsResponse = await github.rest.actions.listWorkflowRuns({
                                  owner: context.repo.owner,
                                  repo: context.repo.repo,
                                  workflow_id: workflow.id,
                                  per_page: 50
                              });

                              const recentRuns = runsResponse.data.workflow_runs.filter(run => 
                                  new Date(run.created_at) > historyDate
                              );

                              totalRuns += recentRuns.length;

                              for (const run of recentRuns) {
                                  if (run.conclusion === 'success') {
                                      successfulRuns++;
                                  } else if (run.conclusion === 'failure') {
                                      failedRuns++;
                                  }

                                  if (run.updated_at && run.created_at) {
                                      const duration = new Date(run.updated_at) - new Date(run.created_at);
                                      averageDuration += duration;
                                  }

                                  if (recentBuilds.length < 20) {
                                      recentBuilds.push({
                                          name: workflow.name,
                                          category: category,
                                          status: run.conclusion || run.status,
                                          created_at: run.created_at,
                                          updated_at: run.updated_at,
                                          html_url: run.html_url,
                                          run_number: run.run_number,
                                          event: run.event
                                      });
                                  }
                              }
                          } catch (error) {
                              console.log(`âš ï¸ Error fetching runs for ${workflow.name}: ${error.message}`);
                          }
                      }

                      // Calculate statistics
                      averageDuration = totalRuns > 0 ? Math.round(averageDuration / totalRuns / 1000 / 60) : 0;
                      const successRate = totalRuns > 0 ? ((successfulRuns / totalRuns) * 100).toFixed(1) : 0;

                      const stats = {
                          totalRuns,
                          successfulRuns,
                          failedRuns,
                          successRate,
                          averageDuration,
                          recentBuilds: recentBuilds.sort((a, b) => new Date(b.created_at) - new Date(a.created_at)),
                          workflowCategories: workflowCategories
                      };

                      console.log('âœ… Workflow discovery completed:');
                      Object.keys(workflowCategories).forEach(cat => {
                          console.log(`  - ${cat}: ${workflowCategories[cat].length} workflows`);
                      });

                      return stats;

            - name: Check container registry with configurable credentials
              id: container_stats
              env:
                  # Access Token authentication
                  DOCKER_USERNAME: ${{ env.DOCKER_USERNAME }}
                  DOCKER_ACCESS_TOKEN: ${{ secrets.DOCKERHUB_TOKEN }}
                  DOCKER_REPO: ${{ needs.load-configuration.outputs.docker_repo }}
              run: |
                  echo "ðŸ” Checking container registry with Docker Hub Access Token..."

                  # Access Token masking for security
                  echo "::add-mask::$DOCKER_ACCESS_TOKEN"

                  echo "ðŸ“Š Target repository: $DOCKER_REPO"
                  echo "ðŸ‘¤ Docker username: $DOCKER_USERNAME"

                  # Initialize default values
                  PULL_COUNT=0
                  STAR_COUNT=0
                  LAST_UPDATED="$(date -u +%Y-%m-%dT%H:%M:%SZ)"

                  # Docker Hub Access Token authentication (multiple methods)
                  if [ ! -z "$DOCKER_ACCESS_TOKEN" ] && [ ! -z "$DOCKER_USERNAME" ]; then
                      echo "ðŸ” Using Docker Hub Access Token authentication..."
                      
                      # Method 1: Try Bearer Token authentication
                      echo "ðŸ”‘ Trying Bearer Token authentication..."
                      REPO_INFO=$(curl -s -H "Authorization: Bearer $DOCKER_ACCESS_TOKEN" \
                          "https://hub.docker.com/v2/repositories/${DOCKER_REPO}/" 2>/dev/null)
                      
                      # If Bearer Token fails, Method 2: Use Username + Access Token for JWT
                      if [ -z "$REPO_INFO" ] || echo "$REPO_INFO" | grep -q "error\|unauthorized"; then
                          echo "ðŸ”„ Bearer Token failed, trying Username + Access Token for JWT..."
                          
                          TOKEN_RESPONSE=$(curl -s -X POST \
                              -H "Content-Type: application/json" \
                              -d "{\"username\":\"$DOCKER_USERNAME\",\"password\":\"$DOCKER_ACCESS_TOKEN\"}" \
                              "https://hub.docker.com/v2/users/login/" 2>/dev/null)
                          
                          if echo "$TOKEN_RESPONSE" | jq -e .token >/dev/null 2>&1; then
                              JWT_TOKEN=$(echo "$TOKEN_RESPONSE" | jq -r .token)
                              echo "âœ… JWT Token obtained successfully"
                              
                              # Authenticated API call with JWT Token
                              REPO_INFO=$(curl -s -H "Authorization: JWT $JWT_TOKEN" \
                                  "https://hub.docker.com/v2/repositories/${DOCKER_REPO}/" 2>/dev/null)
                              
                              if [ ! -z "$REPO_INFO" ] && ! echo "$REPO_INFO" | grep -q "error\|unauthorized"; then
                                  echo "âœ… Docker Hub authentication successful with JWT"
                              else
                                  echo "âš ï¸ JWT authentication failed"
                                  REPO_INFO=""
                              fi
                          else
                              echo "âš ï¸ Failed to obtain JWT token with Access Token"
                              REPO_INFO=""
                          fi
                      else
                          echo "âœ… Bearer Token authentication successful"
                      fi
                      
                  elif [ ! -z "$DOCKER_ACCESS_TOKEN" ]; then
                      echo "ðŸ”‘ Using Access Token without username (Bearer only)..."
                      REPO_INFO=$(curl -s -H "Authorization: Bearer $DOCKER_ACCESS_TOKEN" \
                          "https://hub.docker.com/v2/repositories/${DOCKER_REPO}/" 2>/dev/null)
                      
                      if [ ! -z "$REPO_INFO" ] && ! echo "$REPO_INFO" | grep -q "error\|unauthorized"; then
                          echo "âœ… Bearer Token authentication successful"
                      else
                          echo "âš ï¸ Bearer Token authentication failed"
                          REPO_INFO=""
                      fi
                  fi

                  # Fallback to Public API if authentication fails
                  if [ -z "$REPO_INFO" ] || echo "$REPO_INFO" | grep -q "error\|unauthorized\|not found"; then
                      echo "ðŸ”„ Authenticated access failed, falling back to public Docker Hub API..."
                      REPO_INFO=$(curl -s "https://hub.docker.com/v2/repositories/${DOCKER_REPO}/" 2>/dev/null || echo '{}')
                      
                      if [ ! -z "$REPO_INFO" ] && [ "$REPO_INFO" != "{}" ]; then
                          echo "ðŸ“Š Using public API data (limited information)"
                      else
                          echo "âš ï¸ No Docker Hub data available for $DOCKER_REPO"
                          REPO_INFO='{"pull_count":0,"star_count":0,"last_updated":null}'
                      fi
                  fi

                  # Data extraction and validation
                  if echo "$REPO_INFO" | jq -e . >/dev/null 2>&1; then
                      PULL_COUNT=$(echo "$REPO_INFO" | jq -r '.pull_count // 0')
                      STAR_COUNT=$(echo "$REPO_INFO" | jq -r '.star_count // 0')
                      LAST_UPDATED=$(echo "$REPO_INFO" | jq -r '.last_updated // ""')
                      
                      if [ -z "$LAST_UPDATED" ] || [ "$LAST_UPDATED" = "null" ]; then
                          LAST_UPDATED="$(date -u +%Y-%m-%dT%H:%M:%SZ)"
                      fi
                      
                      echo "âœ… Docker Hub data retrieved successfully:"
                      echo "  - Total pulls: $PULL_COUNT"
                      echo "  - Stars: $STAR_COUNT"
                      echo "  - Last updated: $LAST_UPDATED"
                  else
                      echo "âš ï¸ Failed to parse Docker Hub response, using defaults"
                      PULL_COUNT=0
                      STAR_COUNT=0
                      LAST_UPDATED="$(date -u +%Y-%m-%dT%H:%M:%SZ)"
                  fi

                  # Additional information with Access Token
                  if [ ! -z "$JWT_TOKEN" ]; then
                      echo "ðŸ” Fetching additional authenticated data..."
                      
                      # Get tags information (detailed info available to authenticated users)
                      TAGS_INFO=$(curl -s -H "Authorization: JWT $JWT_TOKEN" \
                          "https://hub.docker.com/v2/repositories/${DOCKER_REPO}/tags/?page_size=5" 2>/dev/null)
                      
                      if echo "$TAGS_INFO" | jq -e .results >/dev/null 2>&1; then
                          TAG_COUNT=$(echo "$TAGS_INFO" | jq '.results | length')
                          echo "ðŸ“‹ Available tags: $TAG_COUNT (showing recent)"
                          echo "$TAGS_INFO" | jq -r '.results[]?.name' | head -3 | while read tag; do
                              echo "  - $tag"
                          done
                      fi
                      
                      # Repository statistics (detailed info through authenticated access)
                      STATS_INFO=$(curl -s -H "Authorization: JWT $JWT_TOKEN" \
                          "https://hub.docker.com/v2/repositories/${DOCKER_REPO}/analytics/" 2>/dev/null)
                      
                      if echo "$STATS_INFO" | jq -e . >/dev/null 2>&1; then
                          echo "ðŸ“ˆ Additional statistics available through authenticated access"
                      fi
                  fi

                  # Generate JSON output
                  cat > container_stats.json << EOF
                  {
                    "registry_type": "docker_hub",
                    "repository": "$DOCKER_REPO",
                    "pull_count": $PULL_COUNT,
                    "star_count": $STAR_COUNT,
                    "last_updated": "$LAST_UPDATED",
                    "authentication_method": "$([ ! -z "$JWT_TOKEN" ] && echo "access_token_jwt" || [ ! -z "$DOCKER_ACCESS_TOKEN" ] && echo "access_token_bearer" || echo "public_api")",
                    "data_source": "$([ ! -z "$JWT_TOKEN" ] && echo "authenticated" || echo "public")"
                  }
                  EOF

                  echo "container_stats=$(cat container_stats.json | jq -c .)" >> $GITHUB_OUTPUT

                  echo "ðŸŽ‰ Container registry check completed with Access Token authentication"

            - name: External monitoring integration with service-specific control
              if: ${{ fromJson(needs.load-configuration.outputs.external_monitoring_config).master_enable }}
              env:
                  PROMETHEUS_URL: ${{ secrets.PROMETHEUS_URL }}
                  GRAFANA_API_KEY: ${{ secrets.GRAFANA_API_KEY }}
                  GRAFANA_URL: ${{ secrets.GRAFANA_URL }}
                  CUSTOM_MONITORING_WEBHOOK: ${{ secrets.CUSTOM_MONITORING_WEBHOOK }}
              run: |
                  echo "ðŸ”— External monitoring integration with service-specific configuration..."

                  # External service secret masking
                  echo "::add-mask::$GRAFANA_API_KEY"
                  echo "::add-mask::$PROMETHEUS_URL"
                  echo "::add-mask::$GRAFANA_URL"
                  echo "::add-mask::$CUSTOM_MONITORING_WEBHOOK"

                  # Parse service-specific configuration
                  EXTERNAL_CONFIG='${{ needs.load-configuration.outputs.external_monitoring_config }}'
                  PROMETHEUS_ENABLED=$(echo "$EXTERNAL_CONFIG" | jq -r '.prometheus')
                  GRAFANA_ENABLED=$(echo "$EXTERNAL_CONFIG" | jq -r '.grafana')
                  CUSTOM_WEBHOOK_ENABLED=$(echo "$EXTERNAL_CONFIG" | jq -r '.custom_webhook')

                  echo "ðŸ“‹ Service-specific configuration:"
                  echo "  - Prometheus Integration: $PROMETHEUS_ENABLED"
                  echo "  - Grafana Integration: $GRAFANA_ENABLED"
                  echo "  - Custom Webhook Integration: $CUSTOM_WEBHOOK_ENABLED"

                  # Extract dashboard data for metrics
                  DASHBOARD_DATA='${{ needs.collect-metrics.outputs.dashboard_data }}'
                  SUCCESS_RATE=$(echo "$DASHBOARD_DATA" | jq -r '.workflow_stats.successRate // 0')
                  TOTAL_RUNS=$(echo "$DASHBOARD_DATA" | jq -r '.workflow_stats.totalRuns // 0')
                  FAILED_RUNS=$(echo "$DASHBOARD_DATA" | jq -r '.workflow_stats.failedRuns // 0')
                  AVG_DURATION=$(echo "$DASHBOARD_DATA" | jq -r '.workflow_stats.averageDuration // 0')
                  DOCKER_PULLS=$(echo "$DASHBOARD_DATA" | jq -r '.container_stats.pull_count // 0')
                  DOCKER_STARS=$(echo "$DASHBOARD_DATA" | jq -r '.container_stats.star_count // 0')
                  ACTIVE_ISSUES=$(echo "$DASHBOARD_DATA" | jq -r '.active_issues // 0')

                  CURRENT_TIMESTAMP=$(date +%s)
                  REPO_NAME="${{ github.repository }}"

                  echo "ðŸ“Š Extracted metrics for enabled services:"
                  echo "  - Success Rate: ${SUCCESS_RATE}%"
                  echo "  - Total Runs: ${TOTAL_RUNS}"
                  echo "  - Failed Runs: ${FAILED_RUNS}"
                  echo "  - Average Duration: ${AVG_DURATION} minutes"
                  echo "  - Docker Pulls: ${DOCKER_PULLS}"
                  echo "  - Active Issues: ${ACTIVE_ISSUES}"

                  # âœ… Conditional Prometheus Integration
                  if [ "$PROMETHEUS_ENABLED" = "true" ] && [ ! -z "$PROMETHEUS_URL" ]; then
                      echo "ðŸ“ˆ Prometheus integration is ENABLED - sending metrics..."
                      
                      # Create Prometheus metrics file
                      cat > metrics.txt << EOF
                  # HELP github_workflow_success_rate GitHub workflow success rate percentage
                  # TYPE github_workflow_success_rate gauge
                  github_workflow_success_rate{repository="$REPO_NAME",service="github-actions"} $SUCCESS_RATE

                  # HELP github_workflow_total_runs Total GitHub workflow runs in the last period
                  # TYPE github_workflow_total_runs counter
                  github_workflow_total_runs{repository="$REPO_NAME",service="github-actions"} $TOTAL_RUNS

                  # HELP github_workflow_failed_runs Failed GitHub workflow runs in the last period
                  # TYPE github_workflow_failed_runs counter  
                  github_workflow_failed_runs{repository="$REPO_NAME",service="github-actions"} $FAILED_RUNS

                  # HELP github_workflow_average_duration_minutes Average workflow duration in minutes
                  # TYPE github_workflow_average_duration_minutes gauge
                  github_workflow_average_duration_minutes{repository="$REPO_NAME",service="github-actions"} $AVG_DURATION

                  # HELP github_container_pull_count Docker Hub pull count
                  # TYPE github_container_pull_count gauge
                  github_container_pull_count{repository="$REPO_NAME",service="docker-hub"} $DOCKER_PULLS

                  # HELP github_container_star_count Docker Hub star count
                  # TYPE github_container_star_count gauge
                  github_container_star_count{repository="$REPO_NAME",service="docker-hub"} $DOCKER_STARS

                  # HELP github_issues_active_count Active GitHub issues count
                  # TYPE github_issues_active_count gauge
                  github_issues_active_count{repository="$REPO_NAME",service="github-issues"} $ACTIVE_ISSUES

                  # HELP github_dashboard_last_update_timestamp Last dashboard update timestamp
                  # TYPE github_dashboard_last_update_timestamp gauge
                  github_dashboard_last_update_timestamp{repository="$REPO_NAME",service="dashboard"} $CURRENT_TIMESTAMP
                  EOF
                      
                      echo "ðŸ“‹ Generated Prometheus metrics for pushgateway"
                      
                      # Push to Prometheus Pushgateway with job and instance labels
                      JOB_NAME="github_workflow_monitoring"
                      INSTANCE_NAME=$(echo "$REPO_NAME" | tr '/' '_')
                      
                      PROMETHEUS_RESPONSE=$(curl -s -w "%{http_code}" -X POST \
                          --data-binary @metrics.txt \
                          "$PROMETHEUS_URL/metrics/job/$JOB_NAME/instance/$INSTANCE_NAME")
                      
                      HTTP_CODE="${PROMETHEUS_RESPONSE: -3}"
                      if [ "$HTTP_CODE" = "200" ] || [ "$HTTP_CODE" = "202" ]; then
                          echo "âœ… Successfully pushed metrics to Prometheus Pushgateway"
                      else
                          echo "âŒ Failed to push metrics to Prometheus (HTTP: $HTTP_CODE)"
                          echo "Response: ${PROMETHEUS_RESPONSE%???}"
                      fi
                      
                      # Cleanup
                      rm -f metrics.txt
                  elif [ "$PROMETHEUS_ENABLED" = "true" ]; then
                      echo "âš ï¸ Prometheus integration is ENABLED but PROMETHEUS_URL is not configured"
                  else
                      echo "âšª Prometheus integration is DISABLED - skipping"
                  fi

                  # âœ… Conditional Grafana Integration
                  if [ "$GRAFANA_ENABLED" = "true" ] && [ ! -z "$GRAFANA_API_KEY" ] && [ ! -z "$GRAFANA_URL" ]; then
                      echo "ðŸ“Š Grafana integration is ENABLED - creating annotations..."
                      
                      # Create annotation for dashboard update
                      GRAFANA_ANNOTATION=$(cat << EOF
                  {
                      "dashboardUID": "github-workflow-monitoring",
                      "time": $(($CURRENT_TIMESTAMP * 1000)),
                      "timeEnd": $(($CURRENT_TIMESTAMP * 1000)),
                      "tags": ["github-actions", "dashboard-update", "$REPO_NAME"],
                      "text": "Dashboard updated: Success Rate ${SUCCESS_RATE}%, ${FAILED_RUNS} failures, ${TOTAL_RUNS} total runs"
                  }
                  EOF
                      )
                      
                      # Send annotation to Grafana
                      GRAFANA_RESPONSE=$(curl -s -w "%{http_code}" -X POST \
                          "$GRAFANA_URL/api/annotations" \
                          -H "Content-Type: application/json" \
                          -H "Authorization: Bearer $GRAFANA_API_KEY" \
                          -d "$GRAFANA_ANNOTATION")
                      
                      HTTP_CODE="${GRAFANA_RESPONSE: -3}"
                      if [ "$HTTP_CODE" = "200" ]; then
                          echo "âœ… Successfully created Grafana annotation"
                      else
                          echo "âŒ Failed to create Grafana annotation (HTTP: $HTTP_CODE)"
                          echo "Response: ${GRAFANA_RESPONSE%???}"
                      fi
                      
                      # Update Grafana dashboard variables (if dashboard exists)
                      echo "ðŸ”„ Attempting to refresh Grafana dashboard..."
                      DASHBOARD_REFRESH=$(curl -s -w "%{http_code}" -X POST \
                          "$GRAFANA_URL/api/dashboards/uid/github-workflow-monitoring/restore" \
                          -H "Authorization: Bearer $GRAFANA_API_KEY")
                      
                      HTTP_CODE="${DASHBOARD_REFRESH: -3}"
                      if [ "$HTTP_CODE" = "200" ]; then
                          echo "âœ… Grafana dashboard refreshed"
                      else
                          echo "â„¹ï¸ Grafana dashboard refresh not available or not configured"
                      fi
                  elif [ "$GRAFANA_ENABLED" = "true" ]; then
                      echo "âš ï¸ Grafana integration is ENABLED but GRAFANA_API_KEY or GRAFANA_URL is not configured"
                  else
                      echo "âšª Grafana integration is DISABLED - skipping"
                  fi

                  # âœ… Conditional Custom Webhook Integration
                  if [ "$CUSTOM_WEBHOOK_ENABLED" = "true" ] && [ ! -z "$CUSTOM_MONITORING_WEBHOOK" ]; then
                      echo "ðŸ”— Custom webhook integration is ENABLED - sending metrics..."
                      
                      CUSTOM_PAYLOAD=$(cat << EOF
                  {
                      "timestamp": "$CURRENT_TIMESTAMP",
                      "repository": "$REPO_NAME",
                      "metrics": {
                          "success_rate": $SUCCESS_RATE,
                          "total_runs": $TOTAL_RUNS,
                          "failed_runs": $FAILED_RUNS,
                          "average_duration": $AVG_DURATION,
                          "docker_pulls": $DOCKER_PULLS,
                          "docker_stars": $DOCKER_STARS,
                          "active_issues": $ACTIVE_ISSUES
                      },
                      "status": "${{ needs.collect-metrics.outputs.system_health }}",
                      "dashboard_url": "${{ github.server_url }}/${{ github.repository }}/issues?q=is%3Aopen+label%3Aautomation-dashboard"
                  }
                  EOF
                      )
                      
                      CUSTOM_RESPONSE=$(curl -s -w "%{http_code}" -X POST \
                          "$CUSTOM_MONITORING_WEBHOOK" \
                          -H "Content-Type: application/json" \
                          -d "$CUSTOM_PAYLOAD")
                      
                      HTTP_CODE="${CUSTOM_RESPONSE: -3}"
                      if [ "$HTTP_CODE" = "200" ] || [ "$HTTP_CODE" = "201" ] || [ "$HTTP_CODE" = "202" ]; then
                          echo "âœ… Successfully sent metrics to custom webhook"
                      else
                          echo "âŒ Failed to send metrics to custom webhook (HTTP: $HTTP_CODE)"
                      fi
                  elif [ "$CUSTOM_WEBHOOK_ENABLED" = "true" ]; then
                      echo "âš ï¸ Custom webhook integration is ENABLED but CUSTOM_MONITORING_WEBHOOK is not configured"
                  else
                      echo "âšª Custom webhook integration is DISABLED - skipping"
                  fi

                  echo "ðŸŽ‰ External monitoring integration completed!"
                  echo "ðŸ“Š Service Status Summary:"
                  echo "  - Prometheus: $([ "$PROMETHEUS_ENABLED" = "true" ] && [ ! -z "$PROMETHEUS_URL" ] && echo "âœ… Active" || [ "$PROMETHEUS_ENABLED" = "true" ] && echo "âš ï¸ Enabled but not configured" || echo "âšª Disabled")"
                  echo "  - Grafana: $([ "$GRAFANA_ENABLED" = "true" ] && [ ! -z "$GRAFANA_API_KEY" ] && [ ! -z "$GRAFANA_URL" ] && echo "âœ… Active" || [ "$GRAFANA_ENABLED" = "true" ] && echo "âš ï¸ Enabled but not configured" || echo "âšª Disabled")"
                  echo "  - Custom Webhook: $([ "$CUSTOM_WEBHOOK_ENABLED" = "true" ] && [ ! -z "$CUSTOM_MONITORING_WEBHOOK" ] && echo "âœ… Active" || [ "$CUSTOM_WEBHOOK_ENABLED" = "true" ] && echo "âš ï¸ Enabled but not configured" || echo "âšª Disabled")"

            - name: Analyze system health with configurable thresholds
              id: system_health
              uses: actions/github-script@v7
              with:
                  script: |
                      const workflowStats = ${{ steps.discover_workflows.outputs.result }};
                      const healthThresholds = JSON.parse('${{ needs.load-configuration.outputs.health_thresholds }}');

                      console.log(`ðŸŽ¯ Using configured health thresholds: Warning <${healthThresholds.warning}%, Critical <${healthThresholds.critical}%`);

                      let healthStatus = 'healthy';
                      let healthIssues = [];

                      const successRate = parseFloat(workflowStats.successRate);
                      if (successRate < healthThresholds.critical) {
                          healthStatus = 'unhealthy';
                          healthIssues.push(`Critical: Success rate ${successRate}% below ${healthThresholds.critical}%`);
                      } else if (successRate < healthThresholds.warning) {
                          healthStatus = 'degraded';
                          healthIssues.push(`Warning: Success rate ${successRate}% below ${healthThresholds.warning}%`);
                      }

                      // Check for recent failures (last 24 hours)
                      const twentyFourHoursAgo = new Date(Date.now() - 24 * 60 * 60 * 1000);
                      const recentFailures = workflowStats.recentBuilds.filter(build => 
                          build.status === 'failure' && 
                          new Date(build.created_at) > twentyFourHoursAgo
                      );

                      if (recentFailures.length > 3) {
                          healthStatus = 'unhealthy';
                          healthIssues.push(`Critical: ${recentFailures.length} failures in last 24 hours`);
                      } else if (recentFailures.length > 1) {
                          if (healthStatus === 'healthy') healthStatus = 'degraded';
                          healthIssues.push(`Warning: ${recentFailures.length} failures in last 24 hours`);
                      }

                      // Check for stuck workflows
                      const runningBuilds = workflowStats.recentBuilds.filter(build => 
                          (build.status === 'in_progress' || build.status === 'queued') &&
                          new Date(build.created_at) < new Date(Date.now() - 2 * 60 * 60 * 1000) // 2 hours
                      );

                      if (runningBuilds.length > 0) {
                          if (healthStatus === 'healthy') healthStatus = 'degraded';
                          healthIssues.push(`Warning: ${runningBuilds.length} workflows running >2 hours`);
                      }

                      const healthData = {
                          status: healthStatus,
                          issues: healthIssues,
                          last_check: new Date().toISOString(),
                          thresholds: {
                              warning: healthThresholds.warning,
                              critical: healthThresholds.critical
                          }
                      };

                      console.log('ðŸ“Š System health analysis:', healthData);
                      return healthData;

            - name: Compile universal dashboard data
              id: compile_data
              uses: actions/github-script@v7
              with:
                  script: |
                      console.log('ðŸ”— Starting dashboard data compilation...');


                      function safeJsonParse(jsonString, defaultValue = {}) {
                          try {
                              if (!jsonString || jsonString.trim() === '' || jsonString === 'undefined' || jsonString === 'null') {
                                  console.log('âš ï¸ Empty or invalid JSON string, using default value');
                                  return defaultValue;
                              }
                              return JSON.parse(jsonString);
                          } catch (error) {
                              console.log(`âŒ JSON parsing error: ${error.message}`);
                              console.log(`Raw input: "${jsonString}"`);
                              return defaultValue;
                          }
                      }


                      console.log('ðŸ“Š Parsing workflow statistics...');
                      const workflowStatsRaw = '${{ steps.discover_workflows.outputs.result }}';
                      const workflowStats = safeJsonParse(workflowStatsRaw, {
                          totalRuns: 0,
                          successfulRuns: 0,
                          failedRuns: 0,
                          successRate: 0,
                          averageDuration: 0,
                          recentBuilds: [],
                          workflowCategories: {}
                      });
                      console.log(`âœ… Workflow stats parsed: ${workflowStats.totalRuns} total runs`);

                      console.log('ðŸ³ Parsing container statistics...');
                      const containerStatsRaw = '${{ steps.container_stats.outputs.container_stats }}';
                      const containerStats = safeJsonParse(containerStatsRaw, {
                          registry_type: "docker_hub",
                          repository: "unknown/unknown",
                          pull_count: 0,
                          star_count: 0,
                          last_updated: new Date().toISOString(),
                          authentication_method: "fallback",
                          data_source: "default"
                      });
                      console.log(`âœ… Container stats parsed: ${containerStats.pull_count} pulls`);

                      console.log('ðŸ¥ Parsing health data...');
                      const healthDataRaw = '${{ steps.system_health.outputs.result }}';
                      const healthData = safeJsonParse(healthDataRaw, {
                          status: 'unknown',
                          issues: [],
                          last_check: new Date().toISOString(),
                          thresholds: { warning: 90, critical: 95 }
                      });
                      console.log(`âœ… Health data parsed: status = ${healthData.status}`);


                      console.log('âš™ï¸ Parsing monitoring configuration...');
                      const monitoringConfigRaw = '${{ needs.load-configuration.outputs.monitoring_config }}';
                      const monitoringConfig = safeJsonParse(monitoringConfigRaw, {
                          labels: ['automation', 'ci', 'build', 'deploy'],
                          history_days: 30,
                          update_frequency: '*/30 * * * *'
                      });
                      console.log(`âœ… Monitoring config parsed: ${monitoringConfig.labels.length} labels`);


                      let activeAutomationIssues = 0;
                      try {
                          console.log('ðŸ” Checking for active automation issues...');
                          const issuesResponse = await github.rest.issues.listForRepo({
                              owner: context.repo.owner,
                              repo: context.repo.repo,
                              labels: monitoringConfig.labels.join(','),
                              state: 'open'
                          });
                          activeAutomationIssues = issuesResponse.data.length;
                          console.log(`âœ… Found ${activeAutomationIssues} active automation issues`);
                      } catch (error) {
                          console.log(`âš ï¸ Failed to fetch issues: ${error.message}`);
                          activeAutomationIssues = 0;
                      }


                      const dashboardData = {
                          last_updated: new Date().toISOString(),
                          system_health: healthData,
                          workflow_stats: workflowStats,
                          container_stats: containerStats,
                          active_issues: activeAutomationIssues,
                          repository: `${context.repo.owner}/${context.repo.repo}`,
                          metadata: {
                              generated_by: 'universal-automation-dashboard',
                              github_run: context.runId,
                              version: '2.0.0',
                              compilation_status: 'success'
                          }
                      };


                      console.log('ðŸ” Validating compiled data...');
                      const requiredFields = ['last_updated', 'system_health', 'workflow_stats', 'container_stats'];
                      const missingFields = requiredFields.filter(field => !dashboardData[field]);

                      if (missingFields.length > 0) {
                          console.log(`âš ï¸ Missing required fields: ${missingFields.join(', ')}`);
                          
                          missingFields.forEach(field => {
                              dashboardData[field] = {};
                          });
                      }


                      const dashboardDataString = JSON.stringify(dashboardData);
                      console.log(`ðŸ“Š Dashboard data size: ${dashboardDataString.length} characters`);

                      core.setOutput('dashboard_json', dashboardDataString);
                      core.setOutput('last_updated', dashboardData.last_updated);
                      core.setOutput('system_health', healthData.status);

                      console.log('âœ… Dashboard data compilation completed successfully');
                      console.log('ðŸ“‹ Summary:');
                      console.log(`  - Workflow Runs: ${workflowStats.totalRuns}`);
                      console.log(`  - Success Rate: ${workflowStats.successRate}%`);
                      console.log(`  - Container Pulls: ${containerStats.pull_count}`);
                      console.log(`  - System Health: ${healthData.status}`);
                      console.log(`  - Active Issues: ${activeAutomationIssues}`);

                      return dashboardData;

    update-dashboard:
        needs: [load-configuration, collect-metrics]
        runs-on: ubuntu-latest

        steps:
            - name: Find existing dashboard issue
              id: find_issue
              uses: actions/github-script@v7
              with:
                  script: |
                      const issues = await github.rest.issues.listForRepo({
                          owner: context.repo.owner,
                          repo: context.repo.repo,
                          labels: 'automation-dashboard',
                          state: 'open'
                      });

                      const dashboardIssue = issues.data.find(issue => 
                          issue.title.includes('ðŸ¤– Automation Dashboard')
                      );

                      if (dashboardIssue) {
                          console.log(`Found existing dashboard issue: #${dashboardIssue.number}`);
                          return dashboardIssue.number;
                      } else {
                          console.log('No existing dashboard issue found');
                          return null;
                      }
            - name: Get previous dashboard data for comparison
              id: get_previous_data
              uses: actions/github-script@v7
              with:
                  script: |
                      const existingIssueNumber = ${{ steps.find_issue.outputs.result }};
                      let previousData = {
                          success_rate: 0,
                          total_runs: 0,
                          failed_runs: 0,
                          docker_pulls: 0,
                          active_issues: 0,
                          update_count: 0
                      };

                      if (existingIssueNumber) {
                          try {
                              const issue = await github.rest.issues.get({
                                  owner: context.repo.owner,
                                  repo: context.repo.repo,
                                  issue_number: existingIssueNumber
                              });

                              // Extract previous data from issue body using regex
                              const body = issue.data.body;
                              
                              const successRateMatch = body.match(/Success Rate.*?(\d+(?:\.\d+)?)%/);
                              const totalRunsMatch = body.match(/Total Runs.*?(\d+)/);
                              const failedRunsMatch = body.match(/Failed Runs.*?(\d+)/);
                              const dockerPullsMatch = body.match(/Total Pulls.*?(\d+(?:,\d+)*)/);
                              const activeIssuesMatch = body.match(/Current open automation issues: (\d+)/);
                              const updateMatch = body.match(/Update #.*?(\d+)/);

                              if (successRateMatch) previousData.success_rate = parseFloat(successRateMatch[1]);
                              if (totalRunsMatch) previousData.total_runs = parseInt(totalRunsMatch[1]);
                              if (failedRunsMatch) previousData.failed_runs = parseInt(failedRunsMatch[1]);
                              if (dockerPullsMatch) previousData.docker_pulls = parseInt(dockerPullsMatch[1].replace(/,/g, ''));
                              if (activeIssuesMatch) previousData.active_issues = parseInt(activeIssuesMatch[1]);
                              if (updateMatch) previousData.update_count = parseInt(updateMatch[1]);

                              console.log('ðŸ“Š Previous data extracted:', previousData);
                          } catch (error) {
                              console.log('âš ï¸ Could not extract previous data:', error.message);
                          }
                      }

                      return previousData;

            - name: Generate configurable dashboard content
              run: |
                  PROJECT_NAME="${{ env.PROJECT_DISPLAY_NAME || github.repository }}"
                  PROJECT_DESCRIPTION="${{ env.PROJECT_DESCRIPTION || 'Automated project monitoring' }}"
                  DOCKER_REPO="${{ needs.load-configuration.outputs.docker_repo }}"

                  # âœ… ìˆ˜ì •ëœ í…œí”Œë¦¿ - placeholderë¥¼ í…Œì´ë¸” í–‰ ë°–ìœ¼ë¡œ ì´ë™
                  cat > dashboard_content.md << EOF
                  ## ðŸ¤– ${PROJECT_NAME} - Automation Dashboard

                  **Description**: ${PROJECT_DESCRIPTION}
                  **Docker Repository**: [\`${DOCKER_REPO}\`](https://hub.docker.com/r/${DOCKER_REPO})
                  **Configuration**: Variables & Secrets based
                  **Last Updated**: ${{ needs.collect-metrics.outputs.last_updated }}
                  **System Health**: SYSTEM_HEALTH_PLACEHOLDER
                  **Update #**: UPDATE_NUMBER_PLACEHOLDER

                  ### ðŸ“Š Live Tracking Information

                  | Metric | Current Value | Previous Value | Trend |
                  |--------|---------------|----------------|-------|
                  | Success Rate | SUCCESS_RATE_CURRENT% | PREV_SUCCESS_RATE% | TREND_SUCCESS_RATE |
                  | Total Runs | TOTAL_RUNS_CURRENT | PREV_TOTAL_RUNS | TREND_TOTAL_RUNS |
                  | Failed Runs | FAILED_RUNS_CURRENT | PREV_FAILED_RUNS | TREND_FAILED_RUNS |
                  | Docker Pulls | DOCKER_PULLS_CURRENT | PREV_DOCKER_PULLS | TREND_DOCKER_PULLS |
                  | Active Issues | ACTIVE_ISSUES_CURRENT | PREV_ACTIVE_ISSUES | TREND_ACTIVE_ISSUES |

                  ### âš™ï¸ Current Configuration

                  | Setting | Value | Source |
                  |---------|-------|--------|
                  | Health Warning Threshold | ${{ fromJson(needs.load-configuration.outputs.health_thresholds).warning }}% | Variables |
                  | Health Critical Threshold | ${{ fromJson(needs.load-configuration.outputs.health_thresholds).critical }}% | Variables |
                  | History Period | ${{ fromJson(needs.load-configuration.outputs.monitoring_config).history_days }} days | Variables |
                  | Update Frequency | ${{ fromJson(needs.load-configuration.outputs.monitoring_config).update_frequency }} | Variables |
                  | Health Alerts | ${{ fromJson(needs.load-configuration.outputs.notification_config).health_alerts }} | Variables |
                  | Slack Notifications | ${{ fromJson(needs.load-configuration.outputs.notification_config).slack_notifications }} | Variables |
                  | Teams Notifications | ${{ fromJson(needs.load-configuration.outputs.notification_config).teams_notifications }} | Variables |
                  | Discord Notifications | ${{ fromJson(needs.load-configuration.outputs.notification_config).discord_notifications }} | Variables |
                  | External Monitoring Master | ${{ fromJson(needs.load-configuration.outputs.external_monitoring_config).master_enable }} | Variables |
                  | Prometheus Integration | ${{ fromJson(needs.load-configuration.outputs.external_monitoring_config).prometheus }} | Variables |
                  | Grafana Integration | ${{ fromJson(needs.load-configuration.outputs.external_monitoring_config).grafana }} | Variables |
                  | Custom Webhook Integration | ${{ fromJson(needs.load-configuration.outputs.external_monitoring_config).custom_webhook }} | Variables |

                  ### ðŸ”§ Configuration Management

                  To customize this dashboard, update the following in your repository settings:

                  **Variables** (Repository Settings â†’ Secrets and variables â†’ Actions â†’ Variables):
                  - \`DOCKER_USERNAME\`: Your Docker Hub username
                  - \`DOCKER_REPOSITORY\`: Docker repository name (optional)
                  - \`HEALTH_WARNING_THRESHOLD\`: Warning threshold percentage (default: 90)
                  - \`HEALTH_CRITICAL_THRESHOLD\`: Critical threshold percentage (default: 95)
                  - \`MONITORING_LABELS\`: Comma-separated labels to monitor (default: automation,ci,build,deploy)
                  - \`PROJECT_DISPLAY_NAME\`: Custom project display name
                  - \`PROJECT_DESCRIPTION\`: Project description
                  - \`DASHBOARD_SCHEDULE\`: Cron schedule for updates (default: every 30 minutes)
                  - \`HISTORY_DAYS\`: Historical data period in days (default: 30)
                  - \`ENABLE_HEALTH_ALERTS\`: Enable health alerts (default: true)
                  - \`ENABLE_SLACK_NOTIFICATIONS\`: Enable Slack notifications (default: false)
                  - \`ENABLE_TEAMS_NOTIFICATIONS\`: Enable Teams notifications (default: false)
                  - \`ENABLE_DISCORD_NOTIFICATIONS\`: Enable Discord notifications (default: false)
                  - \`ENABLE_EXTERNAL_MONITORING\`: Enable external monitoring integration (default: false)
                  - \`ENABLE_PROMETHEUS_INTEGRATION\`: Enable Prometheus integration (default: false)
                  - \`ENABLE_GRAFANA_INTEGRATION\`: Enable Grafana integration (default: false)
                  - \`ENABLE_CUSTOM_WEBHOOK_INTEGRATION\`: Enable custom webhook integration (default: false)

                  **Secrets** (Repository Settings â†’ Secrets and variables â†’ Actions â†’ Secrets):
                  - \`DOCKERHUB_TOKEN\`: Docker Hub access token
                  - \`SLACK_WEBHOOK_URL\`: Slack webhook for notifications (optional)
                  - \`TEAMS_WEBHOOK_URL\`: Microsoft Teams webhook for notifications (optional)
                  - \`DISCORD_WEBHOOK_URL\`: Discord webhook for notifications (optional)
                  - \`PROMETHEUS_URL\`: Prometheus Pushgateway URL (optional)
                  - \`GRAFANA_API_KEY\`: Grafana API key (optional)
                  - \`GRAFANA_URL\`: Grafana instance URL (optional)
                  - \`CUSTOM_MONITORING_WEBHOOK\`: Custom monitoring webhook URL (optional)

                  ### ðŸŽ¯ Service Integration Status

                  Current configuration status based on your Variables and Secrets:

                  | Service | Status | Required Variables | Required Secrets |
                  |---------|--------|-------------------|------------------|
                  | **Docker Hub** | ${{ env.DOCKER_USERNAME && 'âœ… Configured' || 'âš ï¸ Missing DOCKER_USERNAME' }} | DOCKER_USERNAME | DOCKERHUB_TOKEN |
                  | **Health Alerts** | ${{ env.ENABLE_HEALTH_ALERTS == 'true' && 'âœ… Enabled' || 'âšª Disabled' }} | ENABLE_HEALTH_ALERTS | - |
                  | **Slack Notifications** | ${{ env.ENABLE_SLACK_NOTIFICATIONS == 'true' && 'âœ… Enabled' || 'âšª Disabled' }} | ENABLE_SLACK_NOTIFICATIONS | SLACK_WEBHOOK_URL |
                  | **Teams Notifications** | ${{ env.ENABLE_TEAMS_NOTIFICATIONS == 'true' && 'âœ… Enabled' || 'âšª Disabled' }} | ENABLE_TEAMS_NOTIFICATIONS | TEAMS_WEBHOOK_URL |
                  | **Discord Notifications** | ${{ env.ENABLE_DISCORD_NOTIFICATIONS == 'true' && 'âœ… Enabled' || 'âšª Disabled' }} | ENABLE_DISCORD_NOTIFICATIONS | DISCORD_WEBHOOK_URL |
                  | **Prometheus Integration** | ${{ env.ENABLE_PROMETHEUS_INTEGRATION == 'true' && 'âœ… Enabled' || 'âšª Disabled' }} | ENABLE_PROMETHEUS_INTEGRATION | PROMETHEUS_URL |
                  | **Grafana Integration** | ${{ env.ENABLE_GRAFANA_INTEGRATION == 'true' && 'âœ… Enabled' || 'âšª Disabled' }} | ENABLE_GRAFANA_INTEGRATION | GRAFANA_API_KEY, GRAFANA_URL |
                  | **Custom Webhook** | ${{ env.ENABLE_CUSTOM_WEBHOOK_INTEGRATION == 'true' && 'âœ… Enabled' || 'âšª Disabled' }} | ENABLE_CUSTOM_WEBHOOK_INTEGRATION | CUSTOM_MONITORING_WEBHOOK |

                  ### ðŸ”— Setup Links

                  - [ðŸ“– Variables Setup Guide](../../settings/variables/actions)
                  - [ðŸ” Secrets Setup Guide](../../settings/secrets/actions)
                  - [ðŸ“Š Docker Hub Access Token](https://hub.docker.com/settings/security)
                  - [ðŸ“± Slack Webhook Setup](https://api.slack.com/messaging/webhooks)
                  - [ðŸ’¼ Teams Webhook Setup](https://docs.microsoft.com/en-us/microsoftteams/platform/webhooks-and-connectors/how-to/add-incoming-webhook)
                  - [ðŸŽ® Discord Webhook Setup](https://support.discord.com/hc/en-us/articles/228383668-Intro-to-Webhooks)
                  - [ðŸ“Š Grafana API Key](https://grafana.com/docs/grafana/latest/administration/api-keys/)

                  ### ðŸ“Š Current Automation Status

                  | Component | Status | Category | Last Activity |
                  |-----------|--------|----------|---------------|
                  WORKFLOW_STATUS_TABLE

                  ### ðŸ“ˆ Performance Metrics (Last ${{ fromJson(needs.load-configuration.outputs.monitoring_config).history_days }} Days)

                  - **Total Runs**: TOTAL_RUNS
                  - **Success Rate**: SUCCESS_RATE%
                  - **Average Duration**: AVERAGE_DURATION minutes
                  - **Failed Runs**: FAILED_RUNS

                  ### ðŸ—ï¸ Recent Activity

                  | Workflow | Category | Status | Run # | Time |
                  |----------|----------|--------|-------|------|
                  RECENT_BUILDS_TABLE

                  ### ðŸ“¦ Container Registry

                  - **Repository**: [\`${DOCKER_REPO}\`](https://hub.docker.com/r/${DOCKER_REPO})
                  - **Total Pulls**: CONTAINER_PULLS
                  - **Stars**: CONTAINER_STARS
                  - **Last Updated**: CONTAINER_UPDATED

                  ### ðŸŽ¯ Active Issues

                  Current open automation issues: ACTIVE_ISSUES

                  ---

                  ### ðŸ”§ Quick Actions

                  | Action | Description |
                  |--------|-------------|
                  | [ðŸ”„ Refresh Dashboard](../../actions/workflows/universal-automation-dashboard.yml) | Manually refresh this dashboard |
                  | [ðŸ“Š View All Workflows](../../actions) | View all workflow runs |
                  | [ðŸ› Create Issue](../../issues/new) | Report a problem |

                  ### ðŸ“‹ Health Indicators

                  - ðŸŸ¢ **Healthy**: All systems operational
                  - ðŸŸ¡ **Degraded**: Minor issues detected
                  - ðŸ”´ **Unhealthy**: Significant issues requiring attention

                  ---

                  ### ðŸ“Š Real-time Update Log

                  REALTIME_LOG_PLACEHOLDER

                  ---

                  *ðŸ¤– This dashboard automatically adapts to any project and updates regularly.*

                  *ðŸ“Š Data source: GitHub Actions API + Container Registry APIs*

                  *âš™ï¸ Generated by Universal Automation Dashboard v2.0.0*

                  *ðŸ”„ Auto-updated every ${{ fromJson(needs.load-configuration.outputs.monitoring_config).update_frequency }}*
                  EOF

            - name: Create or update dashboard issue with real-time tracking
              uses: actions/github-script@v7
              with:
                  script: |
                      const fs = require('fs');
                      const dashboardContent = fs.readFileSync('dashboard_content.md', 'utf8');
                      const existingIssueNumber = ${{ steps.find_issue.outputs.result }};
                      const dashboardData = JSON.parse('${{ needs.collect-metrics.outputs.dashboard_data }}');
                      const previousData = ${{ steps.get_previous_data.outputs.result }};

                      const workflowStats = dashboardData.workflow_stats;
                      const containerStats = dashboardData.container_stats;


                      const systemHealthStatus = '${{ needs.collect-metrics.outputs.system_health }}';
                      const healthDisplay = systemHealthStatus === 'healthy' ? 'ðŸŸ¢ Healthy' : 
                                          systemHealthStatus === 'degraded' ? 'ðŸŸ¡ Degraded' : 'ðŸ”´ Unhealthy';

                      console.log(`ðŸ“Š System health status: ${systemHealthStatus} -> ${healthDisplay}`);


                      const currentData = {
                          success_rate: parseFloat(workflowStats.successRate) || 0,
                          total_runs: workflowStats.totalRuns || 0,
                          failed_runs: workflowStats.failedRuns || 0,
                          docker_pulls: containerStats.pull_count || 0,
                          active_issues: dashboardData.active_issues || 0
                      };

                      const updateCount = (previousData.update_count || 0) + 1;


                      function getTrend(current, previous) {
                          if (previous === 0) return 'ðŸ†• New';
                          if (current > previous) return 'ðŸ“ˆ Up';
                          if (current < previous) return 'ðŸ“‰ Down';
                          return 'âž– Same';
                      }

                      const trends = {
                          success_rate: getTrend(currentData.success_rate, previousData.success_rate),
                          total_runs: getTrend(currentData.total_runs, previousData.total_runs),
                          failed_runs: getTrend(currentData.failed_runs, previousData.failed_runs),
                          docker_pulls: getTrend(currentData.docker_pulls, previousData.docker_pulls),
                          active_issues: getTrend(currentData.active_issues, previousData.active_issues)
                      };


                      let workflowStatusTable = '';
                      Object.entries(workflowStats.workflowCategories).forEach(([category, workflows]) => {
                          if (workflows.length > 0) {
                              const categoryStatus = 'âœ… Active';
                              const lastActivity = 'Recent';
                              workflowStatusTable += `| ${category.charAt(0).toUpperCase() + category.slice(1)} Workflows | ${categoryStatus} | ${category} | ${lastActivity} |\n`;
                          }
                      });

                      if (!workflowStatusTable) {
                          workflowStatusTable = '| No workflows detected | âš ï¸ None | - | - |';
                      }


                      let recentBuildsTable = '';
                      if (workflowStats.recentBuilds && workflowStats.recentBuilds.length > 0) {
                          recentBuildsTable = workflowStats.recentBuilds.slice(0, 10).map(build => {
                              const status = build.status === 'success' ? 'âœ…' : 
                                          build.status === 'failure' ? 'âŒ' : 
                                          build.status === 'in_progress' ? 'ðŸ”„' : 'â¸ï¸';

                              const buildTime = new Date(build.created_at);
                              const timeAgo = buildTime.toLocaleDateString('en-US', { 
                                  month: 'short', 
                                  day: 'numeric', 
                                  hour: '2-digit', 
                                  minute: '2-digit' 
                              });

                              return `| ${build.name} | ${build.category} | ${status} ${build.status} | [#${build.run_number}](${build.html_url}) | ${timeAgo} |`;
                          }).join('\n');
                      } else {
                          recentBuildsTable = '| No recent activity | - | - | - | - |';
                      }


                      const updateLog = `
                      #### Recent Updates

                      **Update #${updateCount}** - ${new Date().toLocaleString('en-US', { 
                          timeZone: 'Asia/Seoul',
                          year: 'numeric',
                          month: 'short', 
                          day: 'numeric',
                          hour: '2-digit',
                          minute: '2-digit',
                          second: '2-digit'
                      })} KST

                      | Metric | Change | Details |
                      |--------|---------|---------|
                      | Success Rate | ${trends.success_rate} | ${previousData.success_rate}% â†’ ${currentData.success_rate}% |
                      | Total Runs | ${trends.total_runs} | ${previousData.total_runs} â†’ ${currentData.total_runs} |
                      | Failed Runs | ${trends.failed_runs} | ${previousData.failed_runs} â†’ ${currentData.failed_runs} |
                      | Docker Pulls | ${trends.docker_pulls} | ${previousData.docker_pulls.toLocaleString()} â†’ ${currentData.docker_pulls.toLocaleString()} |
                      | Active Issues | ${trends.active_issues} | ${previousData.active_issues} â†’ ${currentData.active_issues} |

                      **Workflow Run**: [#${{ github.run_number }}](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})
                      `;


                      let updatedContent = dashboardContent
                          .replace('WORKFLOW_STATUS_TABLE', workflowStatusTable)  
                          .replace('RECENT_BUILDS_TABLE', recentBuildsTable)      
                          .replace('TOTAL_RUNS', workflowStats.totalRuns || 0)
                          .replace('SUCCESS_RATE', workflowStats.successRate || 0)
                          .replace('AVERAGE_DURATION', workflowStats.averageDuration || 0)
                          .replace('FAILED_RUNS', workflowStats.failedRuns || 0)
                          .replace('CONTAINER_PULLS', containerStats.pull_count.toLocaleString())
                          .replace('CONTAINER_STARS', containerStats.star_count)
                          .replace('CONTAINER_UPDATED', containerStats.last_updated)
                          .replace('ACTIVE_ISSUES', dashboardData.active_issues)
                          .replace('SYSTEM_HEALTH_PLACEHOLDER', healthDisplay)
                          .replace('UPDATE_NUMBER_PLACEHOLDER', updateCount)
                          
                          .replace('SUCCESS_RATE_CURRENT', currentData.success_rate)
                          .replace('PREV_SUCCESS_RATE', previousData.success_rate)
                          .replace('TREND_SUCCESS_RATE', trends.success_rate)
                          .replace('TOTAL_RUNS_CURRENT', currentData.total_runs)
                          .replace('PREV_TOTAL_RUNS', previousData.total_runs)
                          .replace('TREND_TOTAL_RUNS', trends.total_runs)
                          .replace('FAILED_RUNS_CURRENT', currentData.failed_runs)
                          .replace('PREV_FAILED_RUNS', previousData.failed_runs)
                          .replace('TREND_FAILED_RUNS', trends.failed_runs)
                          .replace('DOCKER_PULLS_CURRENT', currentData.docker_pulls.toLocaleString())
                          .replace('PREV_DOCKER_PULLS', previousData.docker_pulls.toLocaleString())
                          .replace('TREND_DOCKER_PULLS', trends.docker_pulls)
                          .replace('ACTIVE_ISSUES_CURRENT', currentData.active_issues)
                          .replace('PREV_ACTIVE_ISSUES', previousData.active_issues)
                          .replace('TREND_ACTIVE_ISSUES', trends.active_issues)
                          .replace('REALTIME_LOG_PLACEHOLDER', updateLog);

                      console.log('âœ… All placeholders replaced successfully');

                      const title = `ðŸ¤– Automation Dashboard - ${{ env.PROJECT_DISPLAY_NAME || github.repository }}`;

                      if (existingIssueNumber) {
                          
                          await github.rest.issues.update({
                              owner: context.repo.owner,
                              repo: context.repo.repo,
                              issue_number: existingIssueNumber,
                              title: title,
                              body: updatedContent
                          });

                          
                          const trackingComment = `## ðŸ”„ Dashboard Update #${updateCount}

                      **Update Time**: ${new Date().toLocaleString('en-US', { 
                          timeZone: 'Asia/Seoul',
                          year: 'numeric',
                          month: 'short', 
                          day: 'numeric',
                          hour: '2-digit',
                          minute: '2-digit',
                          second: '2-digit'
                      })} KST

                      **System Health**: ${healthDisplay}
                      **Trigger**: ${{ github.event_name }} 
                      **Workflow Run**: [#${{ github.run_number }}](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})

                      ### ðŸ“Š Key Metrics
                      - **Success Rate**: ${currentData.success_rate}% (${trends.success_rate.replace('ðŸ“ˆ', '+').replace('ðŸ“‰', '-').replace('âž–', '').replace('ðŸ†•', 'new')})
                      - **Total Runs**: ${currentData.total_runs} (${trends.total_runs.replace('ðŸ“ˆ', '+').replace('ðŸ“‰', '-').replace('âž–', '').replace('ðŸ†•', 'new')})
                      - **Failed Runs**: ${currentData.failed_runs} (${trends.failed_runs.replace('ðŸ“ˆ', '+').replace('ðŸ“‰', '-').replace('âž–', '').replace('ðŸ†•', 'new')})
                      - **Docker Pulls**: ${currentData.docker_pulls.toLocaleString()} (${trends.docker_pulls.replace('ðŸ“ˆ', '+').replace('ðŸ“‰', '-').replace('âž–', '').replace('ðŸ†•', 'new')})

                      ---
                      *Dashboard content updated automatically*`;

                          await github.rest.issues.createComment({
                              owner: context.repo.owner,
                              repo: context.repo.repo,
                              issue_number: existingIssueNumber,
                              body: trackingComment
                          });

                          console.log(`âœ… Updated dashboard issue #${existingIssueNumber} with tracking comment`);
                      } else {
                          
                          const newIssue = await github.rest.issues.create({
                              owner: context.repo.owner,
                              repo: context.repo.repo,
                              title: title,
                              body: updatedContent,
                              labels: ['automation-dashboard', 'pinned', 'enhancement', 'real-time-tracking']
                          });

                          console.log(`âœ… Created new dashboard issue #${newIssue.data.number} with real-time tracking`);
                      }

    notify-health-issues:
        needs: [load-configuration, collect-metrics, update-dashboard]
        if: needs.collect-metrics.outputs.system_health != 'healthy' && fromJson(needs.load-configuration.outputs.notification_config).health_alerts
        runs-on: ubuntu-latest

        steps:
            - name: Send configurable notifications to multiple platforms
              if: ${{ fromJson(needs.load-configuration.outputs.notification_config).slack_notifications || fromJson(needs.load-configuration.outputs.notification_config).teams_notifications || fromJson(needs.load-configuration.outputs.notification_config).discord_notifications }}
              env:
                  SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
                  TEAMS_WEBHOOK_URL: ${{ secrets.TEAMS_WEBHOOK_URL }}
                  DISCORD_WEBHOOK_URL: ${{ secrets.DISCORD_WEBHOOK_URL }}
              run: |
                  PROJECT_NAME="${{ env.PROJECT_DISPLAY_NAME || github.repository }}"
                  HEALTH_STATUS="${{ needs.collect-metrics.outputs.system_health }}"

                  # Webhook URL masking for security
                  echo "::add-mask::$SLACK_WEBHOOK_URL"
                  echo "::add-mask::$TEAMS_WEBHOOK_URL"
                  echo "::add-mask::$DISCORD_WEBHOOK_URL"

                  echo "ðŸ“¢ Sending health alert notifications to configured platforms..."

                  # Slack notification
                  if [ "${{ fromJson(needs.load-configuration.outputs.notification_config).slack_notifications }}" = "true" ] && [ ! -z "$SLACK_WEBHOOK_URL" ]; then
                      echo "ðŸ“± Sending Slack notification..."
                      curl -X POST "$SLACK_WEBHOOK_URL" \
                          -H "Content-Type: application/json" \
                          -d "{
                              \"text\": \"ðŸš¨ Health Alert: ${PROJECT_NAME}\",
                              \"attachments\": [{
                                  \"color\": \"danger\",
                                  \"fields\": [{
                                      \"title\": \"Status\",
                                      \"value\": \"${HEALTH_STATUS}\",
                                      \"short\": true
                                  }, {
                                      \"title\": \"Repository\",
                                      \"value\": \"${{ github.repository }}\",
                                      \"short\": true
                                  }, {
                                      \"title\": \"Dashboard\",
                                      \"value\": \"<${{ github.server_url }}/${{ github.repository }}/issues?q=is%3Aopen+label%3Aautomation-dashboard|View Dashboard>\",
                                      \"short\": true
                                  }]
                              }]
                          }" && echo "âœ… Slack notification sent"
                  fi

                  # Microsoft Teams notification
                  if [ "${{ fromJson(needs.load-configuration.outputs.notification_config).teams_notifications }}" = "true" ] && [ ! -z "$TEAMS_WEBHOOK_URL" ]; then
                      echo "ðŸ’¼ Sending Microsoft Teams notification..."
                      curl -X POST "$TEAMS_WEBHOOK_URL" \
                          -H "Content-Type: application/json" \
                          -d '{
                              "@type": "MessageCard",
                              "@context": "http://schema.org/extensions",
                              "summary": "Health Alert: '"${PROJECT_NAME}"'",
                              "themeColor": "FF0000",
                              "title": "ðŸš¨ Health Alert",
                              "sections": [{
                                  "activityTitle": "Project: '"${PROJECT_NAME}"'",
                                  "facts": [
                                      {"name": "Status", "value": "'"${HEALTH_STATUS}"'"},
                                      {"name": "Repository", "value": "${{ github.repository }}"},
                                      {"name": "Time", "value": "'"$(date -u +%Y-%m-%dT%H:%M:%SZ)"'"}
                                  ],
                                  "markdown": true
                              }],
                              "potentialAction": [{
                                  "@type": "OpenUri",
                                  "name": "View Dashboard",
                                  "targets": [{
                                      "os": "default",
                                      "uri": "${{ github.server_url }}/${{ github.repository }}/issues?q=is%3Aopen+label%3Aautomation-dashboard"
                                  }]
                              }]
                          }' && echo "âœ… Teams notification sent"
                  fi

                  # Discord notification
                  if [ "${{ fromJson(needs.load-configuration.outputs.notification_config).discord_notifications }}" = "true" ] && [ ! -z "$DISCORD_WEBHOOK_URL" ]; then
                      echo "ðŸŽ® Sending Discord notification..."
                      curl -X POST "$DISCORD_WEBHOOK_URL" \
                          -H "Content-Type: application/json" \
                          -d '{
                              "content": "ðŸš¨ **Health Alert**",
                              "embeds": [{
                                  "title": "'"${PROJECT_NAME}"' - System Health Alert",
                                  "color": 16711680,
                                  "fields": [
                                      {"name": "Status", "value": "'"${HEALTH_STATUS}"'", "inline": true},
                                      {"name": "Repository", "value": "${{ github.repository }}", "inline": true},
                                      {"name": "Time", "value": "'"$(date -u +%Y-%m-%dT%H:%M:%SZ)"'", "inline": true}
                                  ],
                                  "footer": {
                                      "text": "Universal Automation Dashboard"
                                  },
                                  "timestamp": "'"$(date -u +%Y-%m-%dT%H:%M:%SZ)"'"
                              }]
                          }' && echo "âœ… Discord notification sent"
                  fi

                  echo "ðŸ“¢ Notification delivery completed for all configured platforms"

    close-health-alert-if-healthy:
        needs: [load-configuration, collect-metrics, update-dashboard]
        if: needs.collect-metrics.outputs.system_health == 'healthy'
        runs-on: ubuntu-latest

        steps:
            - name: Close health alert if system recovered
              uses: actions/github-script@v7
              with:
                  script: |
                      const issues = await github.rest.issues.listForRepo({
                          owner: context.repo.owner,
                          repo: context.repo.repo,
                          labels: 'automation-health-alert',
                          state: 'open'
                      });

                      for (const issue of issues.data) {
                          if (issue.title.includes('ðŸš¨ System Health Alert')) {
                              await github.rest.issues.createComment({
                                  owner: context.repo.owner,
                                  repo: context.repo.repo,
                                  issue_number: issue.number,
                                  body: `## âœ… System Health Recovered!\n\n**Recovery Time**: ${new Date().toISOString()}\n**Status**: ðŸŸ¢ All systems healthy\n\nAll automation components have returned to normal operation.\n\nThis health monitor will remain closed until new issues are detected.`
                              });

                              await github.rest.issues.update({
                                  owner: context.repo.owner,
                                  repo: context.repo.repo,
                                  issue_number: issue.number,
                                  state: 'closed'
                              });

                              console.log(`Closed health alert issue #${issue.number} - system recovered`);
                          }
                      }
