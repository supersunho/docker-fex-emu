name: Universal Automation Dashboard

on:
    schedule:
        # Allow cron schedule to be set via Variables (default provided)
        - cron: "*/30 * * * *"

    workflow_run:
        workflows: ["*"]
        types: [completed, requested]

    workflow_dispatch:
        inputs:
            force_refresh:
                description: "Force refresh all dashboard data"
                required: false
                default: false
                type: boolean
            override_docker_repo:
                description: "Override Docker repository"
                required: false
                default: ""
                type: string

permissions:
    contents: read
    issues: write
    actions: read
env:
    # üìä PROJECT CONFIGURATION
    PROJECT_DISPLAY_NAME: ${{ github.repository }}
    PROJECT_DESCRIPTION: "---"

    # üê≥ DOCKER CONFIGURATION
    DOCKER_USERNAME: ${{ github.repository_owner }}
    DOCKER_REPOSITORY: ${{ github.event.repository.name }}

    # ‚ö° HEALTH MONITORING
    HEALTH_WARNING_THRESHOLD: "90"
    HEALTH_CRITICAL_THRESHOLD: "95"
    HISTORY_DAYS: "30"

    # üîî NOTIFICATIONS
    ENABLE_HEALTH_ALERTS: "true"
    ENABLE_SLACK_NOTIFICATIONS: "false"
    ENABLE_TEAMS_NOTIFICATIONS: "false"
    ENABLE_DISCORD_NOTIFICATIONS: "false"

    # üìà EXTERNAL MONITORING
    ENABLE_EXTERNAL_MONITORING: "false"
    ENABLE_PROMETHEUS_INTEGRATION: "false"
    ENABLE_GRAFANA_INTEGRATION: "false"
    ENABLE_CUSTOM_WEBHOOK_INTEGRATION: "false"

    # ‚öôÔ∏è SYSTEM CONFIGURATION
    MONITORING_LABELS: "automation,ci,build,deploy"
    DASHBOARD_SCHEDULE: "*/30 * * * *"

jobs:
    load-configuration:
        runs-on: ubuntu-latest
        outputs:
            docker_repo: ${{ steps.config.outputs.docker_repo }}
            health_thresholds: ${{ steps.config.outputs.health_thresholds }}
            monitoring_config: ${{ steps.config.outputs.monitoring_config }}
            notification_config: ${{ steps.config.outputs.notification_config }}
            external_monitoring_config: ${{ steps.config.outputs.external_monitoring_config }}

        steps:
            - name: Load project configuration from Variables and Secrets
              id: config
              uses: actions/github-script@v7
              with:
                  script: |
                      console.log('üîß Loading project configuration from GitHub Variables and Secrets...');

                      // Load configuration from GitHub Variables
                      const config = {
                          // Docker configuration (Variables)
                          docker_username: '${{ env.DOCKER_USERNAME }}' || '${{ github.repository_owner }}',
                          docker_repo: '${{ github.event.inputs.override_docker_repo }}' || 
                                      '${{ env.DOCKER_USERNAME }}/'${{ env.DOCKER_REPOSITORY }}' ||
                                      '${{ github.repository_owner }}/${{ github.event.repository.name }}',
                          
                          // Health status thresholds (Variables)
                          health_warning_threshold: '${{ env.HEALTH_WARNING_THRESHOLD }}' || '90',
                          health_critical_threshold: '${{ env.HEALTH_CRITICAL_THRESHOLD }}' || '95',
                          
                          // Monitoring configuration (Variables)
                          monitoring_labels: '${{ env.MONITORING_LABELS }}' || 'automation,ci,build,deploy',
                          dashboard_update_frequency: '*/30 * * * *',
                          history_days: '${{ env.HISTORY_DAYS }}' || '30',
                          
                          // Notification settings (Variables)
                          enable_health_alerts: '${{ env.ENABLE_HEALTH_ALERTS }}' || 'true',
                          enable_slack_notifications: '${{ env.ENABLE_SLACK_NOTIFICATIONS }}' || 'false',
                          enable_teams_notifications: '${{ env.ENABLE_TEAMS_NOTIFICATIONS }}' || 'false',
                          enable_discord_notifications: '${{ env.ENABLE_DISCORD_NOTIFICATIONS }}' || 'false',
                          
                          // External monitoring service-specific settings (Variables) - Datadog removed
                          enable_external_monitoring: '${{ env.ENABLE_EXTERNAL_MONITORING }}' || 'false',
                          enable_prometheus_integration: '${{ env.ENABLE_PROMETHEUS_INTEGRATION }}' || 'false',
                          enable_grafana_integration: '${{ env.ENABLE_GRAFANA_INTEGRATION }}' || 'false',
                          enable_custom_webhook_integration: '${{ env.ENABLE_CUSTOM_WEBHOOK_INTEGRATION }}' || 'false',
                          
                          // Project metadata (Variables)
                          project_display_name: '${{ env.PROJECT_DISPLAY_NAME }}' || '${{ github.repository }}',
                          project_description: '${{ env.PROJECT_DESCRIPTION }}' || 'Automated project monitoring'
                      };

                      console.log('üìã Loaded configuration:');
                      console.log(`  - Docker Repo: ${config.docker_repo}`);
                      console.log(`  - Health Thresholds: Warning ${config.health_warning_threshold}%, Critical ${config.health_critical_threshold}%`);
                      console.log(`  - Monitoring Labels: ${config.monitoring_labels}`);
                      console.log(`  - Update Frequency: ${config.dashboard_update_frequency}`);
                      console.log(`  - Health Alerts: ${config.enable_health_alerts}`);
                      console.log(`  - Slack Notifications: ${config.enable_slack_notifications}`);
                      console.log(`  - Teams Notifications: ${config.enable_teams_notifications}`);
                      console.log(`  - Discord Notifications: ${config.enable_discord_notifications}`);
                      console.log(`  - External Monitoring Master: ${config.enable_external_monitoring}`);
                      console.log(`  - Prometheus Integration: ${config.enable_prometheus_integration}`);
                      console.log(`  - Grafana Integration: ${config.enable_grafana_integration}`);
                      console.log(`  - Custom Webhook Integration: ${config.enable_custom_webhook_integration}`);

                      // Configuration validation
                      const healthThresholds = {
                          warning: parseInt(config.health_warning_threshold),
                          critical: parseInt(config.health_critical_threshold)
                      };

                      if (healthThresholds.warning >= healthThresholds.critical) {
                          console.log('‚ö†Ô∏è Warning: Health warning threshold should be lower than critical threshold');
                          healthThresholds.warning = healthThresholds.critical - 5;
                      }

                      const monitoringConfig = {
                          labels: config.monitoring_labels.split(',').map(l => l.trim()),
                          history_days: parseInt(config.history_days),
                          update_frequency: config.dashboard_update_frequency
                      };

                      const notificationConfig = {
                          health_alerts: config.enable_health_alerts === 'true',
                          slack_notifications: config.enable_slack_notifications === 'true',
                          teams_notifications: config.enable_teams_notifications === 'true',
                          discord_notifications: config.enable_discord_notifications === 'true',fa
                          external_monitoring: config.enable_external_monitoring === 'true'
                      };

                      // External monitoring service-specific configuration (Datadog removed)
                      const externalMonitoringConfig = {
                          master_enable: config.enable_external_monitoring === 'true',
                          prometheus: config.enable_prometheus_integration === 'true',
                          grafana: config.enable_grafana_integration === 'true',
                          custom_webhook: config.enable_custom_webhook_integration === 'true'
                      };

                      // Set outputs
                      core.setOutput('docker_repo', config.docker_repo);
                      core.setOutput('health_thresholds', JSON.stringify(healthThresholds));
                      core.setOutput('monitoring_config', JSON.stringify(monitoringConfig));
                      core.setOutput('notification_config', JSON.stringify(notificationConfig));
                      core.setOutput('external_monitoring_config', JSON.stringify(externalMonitoringConfig));

                      return config;

    collect-metrics:
        needs: load-configuration
        runs-on: ubuntu-latest
        outputs:
            dashboard_data: ${{ steps.compile_data.outputs.dashboard_json }}
            last_updated: ${{ steps.compile_data.outputs.last_updated }}
            system_health: ${{ steps.compile_data.outputs.system_health }}

        steps:
            - name: Checkout repository
              uses: actions/checkout@v4

            - name: Auto-discover workflows with configurable settings
              id: discover_workflows
              uses: actions/github-script@v7
              with:
                  script: |
                      const monitoringConfig = JSON.parse('${{ needs.load-configuration.outputs.monitoring_config }}');

                      console.log(`üîç Auto-discovering workflows with ${monitoringConfig.history_days} days history...`);

                      const historyDate = new Date();
                      historyDate.setDate(historyDate.getDate() - monitoringConfig.history_days);

                      // Get all workflows in repository
                      const workflowsResponse = await github.rest.actions.listRepoWorkflows({
                          owner: context.repo.owner,
                          repo: context.repo.repo
                      });

                      const allWorkflows = workflowsResponse.data.workflows;
                      console.log(`üìã Found ${allWorkflows.length} workflows in repository`);

                      // Auto-categorize workflows based on patterns
                      const workflowCategories = {
                          'build': [],
                          'test': [],
                          'deploy': [],
                          'automation': [],
                          'security': [],
                          'maintenance': [],
                          'other': []
                      };

                      let totalRuns = 0;
                      let successfulRuns = 0;
                      let failedRuns = 0;
                      let averageDuration = 0;
                      let recentBuilds = [];

                      for (const workflow of allWorkflows) {
                          const name = workflow.name.toLowerCase();
                          const path = workflow.path.toLowerCase();

                          console.log(`üîç Analyzing workflow: ${workflow.name}`);

                          // Smart categorization
                          let category = 'other';
                          if (name.includes('build') || name.includes('compile') || name.includes('make')) {
                              category = 'build';
                          } else if (name.includes('test') || name.includes('spec') || name.includes('lint')) {
                              category = 'test';
                          } else if (name.includes('deploy') || name.includes('release') || name.includes('publish')) {
                              category = 'deploy';
                          } else if (name.includes('auto') || name.includes('schedule') || name.includes('cron')) {
                              category = 'automation';
                          } else if (name.includes('security') || name.includes('scan') || name.includes('audit')) {
                              category = 'security';
                          } else if (name.includes('cleanup') || name.includes('maintenance') || name.includes('update')) {
                              category = 'maintenance';
                          }

                          workflowCategories[category].push({
                              ...workflow,
                              category: category
                          });

                          // Get workflow runs for statistics
                          try {
                              const runsResponse = await github.rest.actions.listWorkflowRuns({
                                  owner: context.repo.owner,
                                  repo: context.repo.repo,
                                  workflow_id: workflow.id,
                                  per_page: 50
                              });

                              const recentRuns = runsResponse.data.workflow_runs.filter(run => 
                                  new Date(run.created_at) > historyDate
                              );

                              totalRuns += recentRuns.length;

                              for (const run of recentRuns) {
                                  if (run.conclusion === 'success') {
                                      successfulRuns++;
                                  } else if (run.conclusion === 'failure') {
                                      failedRuns++;
                                  }

                                  if (run.updated_at && run.created_at) {
                                      const duration = new Date(run.updated_at) - new Date(run.created_at);
                                      averageDuration += duration;
                                  }

                                  if (recentBuilds.length < 20) {
                                      recentBuilds.push({
                                          name: workflow.name,
                                          category: category,
                                          status: run.conclusion || run.status,
                                          created_at: run.created_at,
                                          updated_at: run.updated_at,
                                          html_url: run.html_url,
                                          run_number: run.run_number,
                                          event: run.event
                                      });
                                  }
                              }
                          } catch (error) {
                              console.log(`‚ö†Ô∏è Error fetching runs for ${workflow.name}: ${error.message}`);
                          }
                      }

                      // Calculate statistics
                      averageDuration = totalRuns > 0 ? Math.round(averageDuration / totalRuns / 1000 / 60) : 0;
                      const successRate = totalRuns > 0 ? ((successfulRuns / totalRuns) * 100).toFixed(1) : 0;

                      const stats = {
                          totalRuns,
                          successfulRuns,
                          failedRuns,
                          successRate,
                          averageDuration,
                          recentBuilds: recentBuilds.sort((a, b) => new Date(b.created_at) - new Date(a.created_at)),
                          workflowCategories: workflowCategories
                      };

                      console.log('‚úÖ Workflow discovery completed:');
                      Object.keys(workflowCategories).forEach(cat => {
                          console.log(`  - ${cat}: ${workflowCategories[cat].length} workflows`);
                      });

                      return stats;

            - name: Check container registry with configurable credentials
              id: container_stats
              env:
                  # Access Token authentication
                  DOCKER_USERNAME: ${{ env.DOCKER_USERNAME }}
                  DOCKER_ACCESS_TOKEN: ${{ secrets.DOCKERHUB_TOKEN }}
                  DOCKER_REPO: ${{ needs.load-configuration.outputs.docker_repo }}
              run: |
                  echo "üîç Checking container registry with Docker Hub Access Token..."

                  # Access Token masking for security
                  echo "::add-mask::$DOCKER_ACCESS_TOKEN"

                  echo "üìä Target repository: $DOCKER_REPO"
                  echo "üë§ Docker username: $DOCKER_USERNAME"

                  # Initialize default values
                  PULL_COUNT=0
                  STAR_COUNT=0
                  LAST_UPDATED="$(date -u +%Y-%m-%dT%H:%M:%SZ)"

                  # Docker Hub Access Token authentication (multiple methods)
                  if [ ! -z "$DOCKER_ACCESS_TOKEN" ] && [ ! -z "$DOCKER_USERNAME" ]; then
                      echo "üîê Using Docker Hub Access Token authentication..."
                      
                      # Method 1: Try Bearer Token authentication
                      echo "üîë Trying Bearer Token authentication..."
                      REPO_INFO=$(curl -s -H "Authorization: Bearer $DOCKER_ACCESS_TOKEN" \
                          "https://hub.docker.com/v2/repositories/${DOCKER_REPO}/" 2>/dev/null)
                      
                      # If Bearer Token fails, Method 2: Use Username + Access Token for JWT
                      if [ -z "$REPO_INFO" ] || echo "$REPO_INFO" | grep -q "error\|unauthorized"; then
                          echo "üîÑ Bearer Token failed, trying Username + Access Token for JWT..."
                          
                          TOKEN_RESPONSE=$(curl -s -X POST \
                              -H "Content-Type: application/json" \
                              -d "{\"username\":\"$DOCKER_USERNAME\",\"password\":\"$DOCKER_ACCESS_TOKEN\"}" \
                              "https://hub.docker.com/v2/users/login/" 2>/dev/null)
                          
                          if echo "$TOKEN_RESPONSE" | jq -e .token >/dev/null 2>&1; then
                              JWT_TOKEN=$(echo "$TOKEN_RESPONSE" | jq -r .token)
                              echo "‚úÖ JWT Token obtained successfully"
                              
                              # Authenticated API call with JWT Token
                              REPO_INFO=$(curl -s -H "Authorization: JWT $JWT_TOKEN" \
                                  "https://hub.docker.com/v2/repositories/${DOCKER_REPO}/" 2>/dev/null)
                              
                              if [ ! -z "$REPO_INFO" ] && ! echo "$REPO_INFO" | grep -q "error\|unauthorized"; then
                                  echo "‚úÖ Docker Hub authentication successful with JWT"
                              else
                                  echo "‚ö†Ô∏è JWT authentication failed"
                                  REPO_INFO=""
                              fi
                          else
                              echo "‚ö†Ô∏è Failed to obtain JWT token with Access Token"
                              REPO_INFO=""
                          fi
                      else
                          echo "‚úÖ Bearer Token authentication successful"
                      fi
                      
                  elif [ ! -z "$DOCKER_ACCESS_TOKEN" ]; then
                      echo "üîë Using Access Token without username (Bearer only)..."
                      REPO_INFO=$(curl -s -H "Authorization: Bearer $DOCKER_ACCESS_TOKEN" \
                          "https://hub.docker.com/v2/repositories/${DOCKER_REPO}/" 2>/dev/null)
                      
                      if [ ! -z "$REPO_INFO" ] && ! echo "$REPO_INFO" | grep -q "error\|unauthorized"; then
                          echo "‚úÖ Bearer Token authentication successful"
                      else
                          echo "‚ö†Ô∏è Bearer Token authentication failed"
                          REPO_INFO=""
                      fi
                  fi

                  # Fallback to Public API if authentication fails
                  if [ -z "$REPO_INFO" ] || echo "$REPO_INFO" | grep -q "error\|unauthorized\|not found"; then
                      echo "üîÑ Authenticated access failed, falling back to public Docker Hub API..."
                      REPO_INFO=$(curl -s "https://hub.docker.com/v2/repositories/${DOCKER_REPO}/" 2>/dev/null || echo '{}')
                      
                      if [ ! -z "$REPO_INFO" ] && [ "$REPO_INFO" != "{}" ]; then
                          echo "üìä Using public API data (limited information)"
                      else
                          echo "‚ö†Ô∏è No Docker Hub data available for $DOCKER_REPO"
                          REPO_INFO='{"pull_count":0,"star_count":0,"last_updated":null}'
                      fi
                  fi

                  # Data extraction and validation
                  if echo "$REPO_INFO" | jq -e . >/dev/null 2>&1; then
                      PULL_COUNT=$(echo "$REPO_INFO" | jq -r '.pull_count // 0')
                      STAR_COUNT=$(echo "$REPO_INFO" | jq -r '.star_count // 0')
                      LAST_UPDATED=$(echo "$REPO_INFO" | jq -r '.last_updated // ""')
                      
                      if [ -z "$LAST_UPDATED" ] || [ "$LAST_UPDATED" = "null" ]; then
                          LAST_UPDATED="$(date -u +%Y-%m-%dT%H:%M:%SZ)"
                      fi
                      
                      echo "‚úÖ Docker Hub data retrieved successfully:"
                      echo "  - Total pulls: $PULL_COUNT"
                      echo "  - Stars: $STAR_COUNT"
                      echo "  - Last updated: $LAST_UPDATED"
                  else
                      echo "‚ö†Ô∏è Failed to parse Docker Hub response, using defaults"
                      PULL_COUNT=0
                      STAR_COUNT=0
                      LAST_UPDATED="$(date -u +%Y-%m-%dT%H:%M:%SZ)"
                  fi

                  # Additional information with Access Token
                  if [ ! -z "$JWT_TOKEN" ]; then
                      echo "üîç Fetching additional authenticated data..."
                      
                      # Get tags information (detailed info available to authenticated users)
                      TAGS_INFO=$(curl -s -H "Authorization: JWT $JWT_TOKEN" \
                          "https://hub.docker.com/v2/repositories/${DOCKER_REPO}/tags/?page_size=5" 2>/dev/null)
                      
                      if echo "$TAGS_INFO" | jq -e .results >/dev/null 2>&1; then
                          TAG_COUNT=$(echo "$TAGS_INFO" | jq '.results | length')
                          echo "üìã Available tags: $TAG_COUNT (showing recent)"
                          echo "$TAGS_INFO" | jq -r '.results[]?.name' | head -3 | while read tag; do
                              echo "  - $tag"
                          done
                      fi
                      
                      # Repository statistics (detailed info through authenticated access)
                      STATS_INFO=$(curl -s -H "Authorization: JWT $JWT_TOKEN" \
                          "https://hub.docker.com/v2/repositories/${DOCKER_REPO}/analytics/" 2>/dev/null)
                      
                      if echo "$STATS_INFO" | jq -e . >/dev/null 2>&1; then
                          echo "üìà Additional statistics available through authenticated access"
                      fi
                  fi

                  # Generate JSON output
                  cat > container_stats.json << EOF
                  {
                    "registry_type": "docker_hub",
                    "repository": "$DOCKER_REPO",
                    "pull_count": $PULL_COUNT,
                    "star_count": $STAR_COUNT,
                    "last_updated": "$LAST_UPDATED",
                    "authentication_method": "$([ ! -z "$JWT_TOKEN" ] && echo "access_token_jwt" || [ ! -z "$DOCKER_ACCESS_TOKEN" ] && echo "access_token_bearer" || echo "public_api")",
                    "data_source": "$([ ! -z "$JWT_TOKEN" ] && echo "authenticated" || echo "public")"
                  }
                  EOF

                  echo "container_stats=$(cat container_stats.json | jq -c .)" >> $GITHUB_OUTPUT

                  echo "üéâ Container registry check completed with Access Token authentication"

            - name: External monitoring integration with service-specific control
              if: ${{ fromJson(needs.load-configuration.outputs.external_monitoring_config).master_enable }}
              env:
                  PROMETHEUS_URL: ${{ secrets.PROMETHEUS_URL }}
                  GRAFANA_API_KEY: ${{ secrets.GRAFANA_API_KEY }}
                  GRAFANA_URL: ${{ secrets.GRAFANA_URL }}
                  CUSTOM_MONITORING_WEBHOOK: ${{ secrets.CUSTOM_MONITORING_WEBHOOK }}
              run: |
                  echo "üîó External monitoring integration with service-specific configuration..."

                  # External service secret masking
                  echo "::add-mask::$GRAFANA_API_KEY"
                  echo "::add-mask::$PROMETHEUS_URL"
                  echo "::add-mask::$GRAFANA_URL"
                  echo "::add-mask::$CUSTOM_MONITORING_WEBHOOK"

                  # Parse service-specific configuration
                  EXTERNAL_CONFIG='${{ needs.load-configuration.outputs.external_monitoring_config }}'
                  PROMETHEUS_ENABLED=$(echo "$EXTERNAL_CONFIG" | jq -r '.prometheus')
                  GRAFANA_ENABLED=$(echo "$EXTERNAL_CONFIG" | jq -r '.grafana')
                  CUSTOM_WEBHOOK_ENABLED=$(echo "$EXTERNAL_CONFIG" | jq -r '.custom_webhook')

                  echo "üìã Service-specific configuration:"
                  echo "  - Prometheus Integration: $PROMETHEUS_ENABLED"
                  echo "  - Grafana Integration: $GRAFANA_ENABLED"
                  echo "  - Custom Webhook Integration: $CUSTOM_WEBHOOK_ENABLED"

                  # Extract dashboard data for metrics
                  DASHBOARD_DATA='${{ needs.collect-metrics.outputs.dashboard_data }}'
                  SUCCESS_RATE=$(echo "$DASHBOARD_DATA" | jq -r '.workflow_stats.successRate // 0')
                  TOTAL_RUNS=$(echo "$DASHBOARD_DATA" | jq -r '.workflow_stats.totalRuns // 0')
                  FAILED_RUNS=$(echo "$DASHBOARD_DATA" | jq -r '.workflow_stats.failedRuns // 0')
                  AVG_DURATION=$(echo "$DASHBOARD_DATA" | jq -r '.workflow_stats.averageDuration // 0')
                  DOCKER_PULLS=$(echo "$DASHBOARD_DATA" | jq -r '.container_stats.pull_count // 0')
                  DOCKER_STARS=$(echo "$DASHBOARD_DATA" | jq -r '.container_stats.star_count // 0')
                  ACTIVE_ISSUES=$(echo "$DASHBOARD_DATA" | jq -r '.active_issues // 0')

                  CURRENT_TIMESTAMP=$(date +%s)
                  REPO_NAME="${{ github.repository }}"

                  echo "üìä Extracted metrics for enabled services:"
                  echo "  - Success Rate: ${SUCCESS_RATE}%"
                  echo "  - Total Runs: ${TOTAL_RUNS}"
                  echo "  - Failed Runs: ${FAILED_RUNS}"
                  echo "  - Average Duration: ${AVG_DURATION} minutes"
                  echo "  - Docker Pulls: ${DOCKER_PULLS}"
                  echo "  - Active Issues: ${ACTIVE_ISSUES}"

                  # ‚úÖ Conditional Prometheus Integration
                  if [ "$PROMETHEUS_ENABLED" = "true" ] && [ ! -z "$PROMETHEUS_URL" ]; then
                      echo "üìà Prometheus integration is ENABLED - sending metrics..."
                      
                      # Create Prometheus metrics file
                      cat > metrics.txt << EOF
                  # HELP github_workflow_success_rate GitHub workflow success rate percentage
                  # TYPE github_workflow_success_rate gauge
                  github_workflow_success_rate{repository="$REPO_NAME",service="github-actions"} $SUCCESS_RATE

                  # HELP github_workflow_total_runs Total GitHub workflow runs in the last period
                  # TYPE github_workflow_total_runs counter
                  github_workflow_total_runs{repository="$REPO_NAME",service="github-actions"} $TOTAL_RUNS

                  # HELP github_workflow_failed_runs Failed GitHub workflow runs in the last period
                  # TYPE github_workflow_failed_runs counter  
                  github_workflow_failed_runs{repository="$REPO_NAME",service="github-actions"} $FAILED_RUNS

                  # HELP github_workflow_average_duration_minutes Average workflow duration in minutes
                  # TYPE github_workflow_average_duration_minutes gauge
                  github_workflow_average_duration_minutes{repository="$REPO_NAME",service="github-actions"} $AVG_DURATION

                  # HELP github_container_pull_count Docker Hub pull count
                  # TYPE github_container_pull_count gauge
                  github_container_pull_count{repository="$REPO_NAME",service="docker-hub"} $DOCKER_PULLS

                  # HELP github_container_star_count Docker Hub star count
                  # TYPE github_container_star_count gauge
                  github_container_star_count{repository="$REPO_NAME",service="docker-hub"} $DOCKER_STARS

                  # HELP github_issues_active_count Active GitHub issues count
                  # TYPE github_issues_active_count gauge
                  github_issues_active_count{repository="$REPO_NAME",service="github-issues"} $ACTIVE_ISSUES

                  # HELP github_dashboard_last_update_timestamp Last dashboard update timestamp
                  # TYPE github_dashboard_last_update_timestamp gauge
                  github_dashboard_last_update_timestamp{repository="$REPO_NAME",service="dashboard"} $CURRENT_TIMESTAMP
                  EOF
                      
                      echo "üìã Generated Prometheus metrics for pushgateway"
                      
                      # Push to Prometheus Pushgateway with job and instance labels
                      JOB_NAME="github_workflow_monitoring"
                      INSTANCE_NAME=$(echo "$REPO_NAME" | tr '/' '_')
                      
                      PROMETHEUS_RESPONSE=$(curl -s -w "%{http_code}" -X POST \
                          --data-binary @metrics.txt \
                          "$PROMETHEUS_URL/metrics/job/$JOB_NAME/instance/$INSTANCE_NAME")
                      
                      HTTP_CODE="${PROMETHEUS_RESPONSE: -3}"
                      if [ "$HTTP_CODE" = "200" ] || [ "$HTTP_CODE" = "202" ]; then
                          echo "‚úÖ Successfully pushed metrics to Prometheus Pushgateway"
                      else
                          echo "‚ùå Failed to push metrics to Prometheus (HTTP: $HTTP_CODE)"
                          echo "Response: ${PROMETHEUS_RESPONSE%???}"
                      fi
                      
                      # Cleanup
                      rm -f metrics.txt
                  elif [ "$PROMETHEUS_ENABLED" = "true" ]; then
                      echo "‚ö†Ô∏è Prometheus integration is ENABLED but PROMETHEUS_URL is not configured"
                  else
                      echo "‚ö™ Prometheus integration is DISABLED - skipping"
                  fi

                  # ‚úÖ Conditional Grafana Integration
                  if [ "$GRAFANA_ENABLED" = "true" ] && [ ! -z "$GRAFANA_API_KEY" ] && [ ! -z "$GRAFANA_URL" ]; then
                      echo "üìä Grafana integration is ENABLED - creating annotations..."
                      
                      # Create annotation for dashboard update
                      GRAFANA_ANNOTATION=$(cat << EOF
                  {
                      "dashboardUID": "github-workflow-monitoring",
                      "time": $(($CURRENT_TIMESTAMP * 1000)),
                      "timeEnd": $(($CURRENT_TIMESTAMP * 1000)),
                      "tags": ["github-actions", "dashboard-update", "$REPO_NAME"],
                      "text": "Dashboard updated: Success Rate ${SUCCESS_RATE}%, ${FAILED_RUNS} failures, ${TOTAL_RUNS} total runs"
                  }
                  EOF
                      )
                      
                      # Send annotation to Grafana
                      GRAFANA_RESPONSE=$(curl -s -w "%{http_code}" -X POST \
                          "$GRAFANA_URL/api/annotations" \
                          -H "Content-Type: application/json" \
                          -H "Authorization: Bearer $GRAFANA_API_KEY" \
                          -d "$GRAFANA_ANNOTATION")
                      
                      HTTP_CODE="${GRAFANA_RESPONSE: -3}"
                      if [ "$HTTP_CODE" = "200" ]; then
                          echo "‚úÖ Successfully created Grafana annotation"
                      else
                          echo "‚ùå Failed to create Grafana annotation (HTTP: $HTTP_CODE)"
                          echo "Response: ${GRAFANA_RESPONSE%???}"
                      fi
                      
                      # Update Grafana dashboard variables (if dashboard exists)
                      echo "üîÑ Attempting to refresh Grafana dashboard..."
                      DASHBOARD_REFRESH=$(curl -s -w "%{http_code}" -X POST \
                          "$GRAFANA_URL/api/dashboards/uid/github-workflow-monitoring/restore" \
                          -H "Authorization: Bearer $GRAFANA_API_KEY")
                      
                      HTTP_CODE="${DASHBOARD_REFRESH: -3}"
                      if [ "$HTTP_CODE" = "200" ]; then
                          echo "‚úÖ Grafana dashboard refreshed"
                      else
                          echo "‚ÑπÔ∏è Grafana dashboard refresh not available or not configured"
                      fi
                  elif [ "$GRAFANA_ENABLED" = "true" ]; then
                      echo "‚ö†Ô∏è Grafana integration is ENABLED but GRAFANA_API_KEY or GRAFANA_URL is not configured"
                  else
                      echo "‚ö™ Grafana integration is DISABLED - skipping"
                  fi

                  # ‚úÖ Conditional Custom Webhook Integration
                  if [ "$CUSTOM_WEBHOOK_ENABLED" = "true" ] && [ ! -z "$CUSTOM_MONITORING_WEBHOOK" ]; then
                      echo "üîó Custom webhook integration is ENABLED - sending metrics..."
                      
                      CUSTOM_PAYLOAD=$(cat << EOF
                  {
                      "timestamp": "$CURRENT_TIMESTAMP",
                      "repository": "$REPO_NAME",
                      "metrics": {
                          "success_rate": $SUCCESS_RATE,
                          "total_runs": $TOTAL_RUNS,
                          "failed_runs": $FAILED_RUNS,
                          "average_duration": $AVG_DURATION,
                          "docker_pulls": $DOCKER_PULLS,
                          "docker_stars": $DOCKER_STARS,
                          "active_issues": $ACTIVE_ISSUES
                      },
                      "status": "${{ needs.collect-metrics.outputs.system_health }}",
                      "dashboard_url": "${{ github.server_url }}/${{ github.repository }}/issues?q=is%3Aopen+label%3Aautomation-dashboard"
                  }
                  EOF
                      )
                      
                      CUSTOM_RESPONSE=$(curl -s -w "%{http_code}" -X POST \
                          "$CUSTOM_MONITORING_WEBHOOK" \
                          -H "Content-Type: application/json" \
                          -d "$CUSTOM_PAYLOAD")
                      
                      HTTP_CODE="${CUSTOM_RESPONSE: -3}"
                      if [ "$HTTP_CODE" = "200" ] || [ "$HTTP_CODE" = "201" ] || [ "$HTTP_CODE" = "202" ]; then
                          echo "‚úÖ Successfully sent metrics to custom webhook"
                      else
                          echo "‚ùå Failed to send metrics to custom webhook (HTTP: $HTTP_CODE)"
                      fi
                  elif [ "$CUSTOM_WEBHOOK_ENABLED" = "true" ]; then
                      echo "‚ö†Ô∏è Custom webhook integration is ENABLED but CUSTOM_MONITORING_WEBHOOK is not configured"
                  else
                      echo "‚ö™ Custom webhook integration is DISABLED - skipping"
                  fi

                  echo "üéâ External monitoring integration completed!"
                  echo "üìä Service Status Summary:"
                  echo "  - Prometheus: $([ "$PROMETHEUS_ENABLED" = "true" ] && [ ! -z "$PROMETHEUS_URL" ] && echo "‚úÖ Active" || [ "$PROMETHEUS_ENABLED" = "true" ] && echo "‚ö†Ô∏è Enabled but not configured" || echo "‚ö™ Disabled")"
                  echo "  - Grafana: $([ "$GRAFANA_ENABLED" = "true" ] && [ ! -z "$GRAFANA_API_KEY" ] && [ ! -z "$GRAFANA_URL" ] && echo "‚úÖ Active" || [ "$GRAFANA_ENABLED" = "true" ] && echo "‚ö†Ô∏è Enabled but not configured" || echo "‚ö™ Disabled")"
                  echo "  - Custom Webhook: $([ "$CUSTOM_WEBHOOK_ENABLED" = "true" ] && [ ! -z "$CUSTOM_MONITORING_WEBHOOK" ] && echo "‚úÖ Active" || [ "$CUSTOM_WEBHOOK_ENABLED" = "true" ] && echo "‚ö†Ô∏è Enabled but not configured" || echo "‚ö™ Disabled")"

            - name: Analyze system health with configurable thresholds
              id: system_health
              uses: actions/github-script@v7
              with:
                  script: |
                      const workflowStats = ${{ steps.discover_workflows.outputs.result }};
                      const healthThresholds = JSON.parse('${{ needs.load-configuration.outputs.health_thresholds }}');

                      console.log(`üéØ Using configured health thresholds: Warning <${healthThresholds.warning}%, Critical <${healthThresholds.critical}%`);

                      let healthStatus = 'healthy';
                      let healthIssues = [];

                      const successRate = parseFloat(workflowStats.successRate);
                      if (successRate < healthThresholds.critical) {
                          healthStatus = 'unhealthy';
                          healthIssues.push(`Critical: Success rate ${successRate}% below ${healthThresholds.critical}%`);
                      } else if (successRate < healthThresholds.warning) {
                          healthStatus = 'degraded';
                          healthIssues.push(`Warning: Success rate ${successRate}% below ${healthThresholds.warning}%`);
                      }

                      // Check for recent failures (last 24 hours)
                      const twentyFourHoursAgo = new Date(Date.now() - 24 * 60 * 60 * 1000);
                      const recentFailures = workflowStats.recentBuilds.filter(build => 
                          build.status === 'failure' && 
                          new Date(build.created_at) > twentyFourHoursAgo
                      );

                      if (recentFailures.length > 3) {
                          healthStatus = 'unhealthy';
                          healthIssues.push(`Critical: ${recentFailures.length} failures in last 24 hours`);
                      } else if (recentFailures.length > 1) {
                          if (healthStatus === 'healthy') healthStatus = 'degraded';
                          healthIssues.push(`Warning: ${recentFailures.length} failures in last 24 hours`);
                      }

                      // Check for stuck workflows
                      const runningBuilds = workflowStats.recentBuilds.filter(build => 
                          (build.status === 'in_progress' || build.status === 'queued') &&
                          new Date(build.created_at) < new Date(Date.now() - 2 * 60 * 60 * 1000) // 2 hours
                      );

                      if (runningBuilds.length > 0) {
                          if (healthStatus === 'healthy') healthStatus = 'degraded';
                          healthIssues.push(`Warning: ${runningBuilds.length} workflows running >2 hours`);
                      }

                      const healthData = {
                          status: healthStatus,
                          issues: healthIssues,
                          last_check: new Date().toISOString(),
                          thresholds: {
                              warning: healthThresholds.warning,
                              critical: healthThresholds.critical
                          }
                      };

                      console.log('üìä System health analysis:', healthData);
                      return healthData;

            - name: Compile universal dashboard data
              id: compile_data
              uses: actions/github-script@v7
              with:
                  script: |
                      const workflowStats = ${{ steps.discover_workflows.outputs.result }};
                      const containerStats = JSON.parse('${{ steps.container_stats.outputs.container_stats }}');
                      const healthData = ${{ steps.system_health.outputs.result }};

                      // Check for active automation issues
                      const monitoringConfig = JSON.parse('${{ needs.load-configuration.outputs.monitoring_config }}');
                      const issuesResponse = await github.rest.issues.listForRepo({
                          owner: context.repo.owner,
                          repo: context.repo.repo,
                          labels: monitoringConfig.labels.join(','),
                          state: 'open'
                      });

                      const activeAutomationIssues = issuesResponse.data.length;

                      const dashboardData = {
                          last_updated: new Date().toISOString(),
                          system_health: healthData,
                          workflow_stats: workflowStats,
                          container_stats: containerStats,
                          active_issues: activeAutomationIssues,
                          repository: `${context.repo.owner}/${context.repo.repo}`,
                          metadata: {
                              generated_by: 'universal-automation-dashboard',
                              github_run: context.runId,
                              version: '2.0.0'
                          }
                      };

                      // Set outputs
                      core.setOutput('dashboard_json', JSON.stringify(dashboardData));
                      core.setOutput('last_updated', dashboardData.last_updated);
                      core.setOutput('system_health', healthData.status);

                      return dashboardData;

    update-dashboard:
        needs: [load-configuration, collect-metrics]
        runs-on: ubuntu-latest

        steps:
            - name: Find existing dashboard issue
              id: find_issue
              uses: actions/github-script@v7
              with:
                  script: |
                      const issues = await github.rest.issues.listForRepo({
                          owner: context.repo.owner,
                          repo: context.repo.repo,
                          labels: 'automation-dashboard',
                          state: 'open'
                      });

                      const dashboardIssue = issues.data.find(issue => 
                          issue.title.includes('ü§ñ Automation Dashboard')
                      );

                      if (dashboardIssue) {
                          console.log(`Found existing dashboard issue: #${dashboardIssue.number}`);
                          return dashboardIssue.number;
                      } else {
                          console.log('No existing dashboard issue found');
                          return null;
                      }

            - name: Generate configurable dashboard content
              run: |
                  PROJECT_NAME="${{ env.PROJECT_DISPLAY_NAME || github.repository }}"
                  PROJECT_DESCRIPTION="${{ env.PROJECT_DESCRIPTION || 'Automated project monitoring' }}"
                  DOCKER_REPO="${{ needs.load-configuration.outputs.docker_repo }}"

                  # Variables-based fully configurable dashboard
                  cat > dashboard_content.md << EOF
                  ## ü§ñ ${PROJECT_NAME} - Automation Dashboard

                  **Description**: ${PROJECT_DESCRIPTION}
                  **Docker Repository**: [`${DOCKER_REPO}`](https://hub.docker.com/r/${DOCKER_REPO})
                  **Configuration**: Variables & Secrets based
                  **Last Updated**: ${{ needs.collect-metrics.outputs.last_updated }}
                  **System Health**: SYSTEM_HEALTH_PLACEHOLDER

                  ### ‚öôÔ∏è Current Configuration

                  | Setting | Value | Source |
                  |---------|-------|--------|
                  | Health Warning Threshold | ${{ fromJson(needs.load-configuration.outputs.health_thresholds).warning }}% | Variables |
                  | Health Critical Threshold | ${{ fromJson(needs.load-configuration.outputs.health_thresholds).critical }}% | Variables |
                  | History Period | ${{ fromJson(needs.load-configuration.outputs.monitoring_config).history_days }} days | Variables |
                  | Update Frequency | ${{ fromJson(needs.load-configuration.outputs.monitoring_config).update_frequency }} | Variables |
                  | Health Alerts | ${{ fromJson(needs.load-configuration.outputs.notification_config).health_alerts }} | Variables |
                  | Slack Notifications | ${{ fromJson(needs.load-configuration.outputs.notification_config).slack_notifications }} | Variables |
                  | Teams Notifications | ${{ fromJson(needs.load-configuration.outputs.notification_config).teams_notifications }} | Variables |
                  | Discord Notifications | ${{ fromJson(needs.load-configuration.outputs.notification_config).discord_notifications }} | Variables |
                  | External Monitoring Master | ${{ fromJson(needs.load-configuration.outputs.external_monitoring_config).master_enable }} | Variables |
                  | Prometheus Integration | ${{ fromJson(needs.load-configuration.outputs.external_monitoring_config).prometheus }} | Variables |
                  | Grafana Integration | ${{ fromJson(needs.load-configuration.outputs.external_monitoring_config).grafana }} | Variables |
                  | Custom Webhook Integration | ${{ fromJson(needs.load-configuration.outputs.external_monitoring_config).custom_webhook }} | Variables |

                  ### üîß Configuration Management

                  To customize this dashboard, update the following in your repository settings:

                  **Variables** (Repository Settings ‚Üí Secrets and variables ‚Üí Actions ‚Üí Variables):
                  - `DOCKER_USERNAME`: Your Docker Hub username
                  - `DOCKER_REPOSITORY`: Docker repository name (optional)
                  - `HEALTH_WARNING_THRESHOLD`: Warning threshold percentage (default: 90)
                  - `HEALTH_CRITICAL_THRESHOLD`: Critical threshold percentage (default: 95)
                  - `MONITORING_LABELS`: Comma-separated labels to monitor (default: automation,ci,build,deploy)
                  - `PROJECT_DISPLAY_NAME`: Custom project display name
                  - `PROJECT_DESCRIPTION`: Project description
                  - `DASHBOARD_SCHEDULE`: Cron schedule for updates (default: every 30 minutes)
                  - `HISTORY_DAYS`: Historical data period in days (default: 30)
                  - `ENABLE_HEALTH_ALERTS`: Enable health alerts (default: true)
                  - `ENABLE_SLACK_NOTIFICATIONS`: Enable Slack notifications (default: false)
                  - `ENABLE_TEAMS_NOTIFICATIONS`: Enable Teams notifications (default: false)
                  - `ENABLE_DISCORD_NOTIFICATIONS`: Enable Discord notifications (default: false)
                  - `ENABLE_EXTERNAL_MONITORING`: Enable external monitoring integration (default: false)
                  - `ENABLE_PROMETHEUS_INTEGRATION`: Enable Prometheus integration (default: false)
                  - `ENABLE_GRAFANA_INTEGRATION`: Enable Grafana integration (default: false)
                  - `ENABLE_CUSTOM_WEBHOOK_INTEGRATION`: Enable custom webhook integration (default: false)

                  **Secrets** (Repository Settings ‚Üí Secrets and variables ‚Üí Actions ‚Üí Secrets):
                  - `DOCKER_ACCESS_TOKEN`: Docker Hub access token
                  - `SLACK_WEBHOOK_URL`: Slack webhook for notifications (optional)
                  - `TEAMS_WEBHOOK_URL`: Microsoft Teams webhook for notifications (optional)
                  - `DISCORD_WEBHOOK_URL`: Discord webhook for notifications (optional)
                  - `PROMETHEUS_URL`: Prometheus Pushgateway URL (optional)
                  - `GRAFANA_API_KEY`: Grafana API key (optional)
                  - `GRAFANA_URL`: Grafana instance URL (optional)
                  - `CUSTOM_MONITORING_WEBHOOK`: Custom monitoring webhook URL (optional)

                  ### üéØ Service Integration Status

                  Current configuration status based on your Variables and Secrets:

                  | Service | Status | Required Variables | Required Secrets |
                  |---------|--------|-------------------|------------------|
                  | **Docker Hub** | ${{ env.DOCKER_USERNAME && '‚úÖ Configured' || '‚ö†Ô∏è Missing DOCKER_USERNAME' }} | DOCKER_USERNAME | DOCKER_ACCESS_TOKEN |
                  | **Health Alerts** | ${{ env.ENABLE_HEALTH_ALERTS == 'true' && '‚úÖ Enabled' || '‚ö™ Disabled' }} | ENABLE_HEALTH_ALERTS | - |
                  | **Slack Notifications** | ${{ env.ENABLE_SLACK_NOTIFICATIONS == 'true' && '‚úÖ Enabled' || '‚ö™ Disabled' }} | ENABLE_SLACK_NOTIFICATIONS | SLACK_WEBHOOK_URL |
                  | **Teams Notifications** | ${{ env.ENABLE_TEAMS_NOTIFICATIONS == 'true' && '‚úÖ Enabled' || '‚ö™ Disabled' }} | ENABLE_TEAMS_NOTIFICATIONS | TEAMS_WEBHOOK_URL |
                  | **Discord Notifications** | ${{ env.ENABLE_DISCORD_NOTIFICATIONS == 'true' && '‚úÖ Enabled' || '‚ö™ Disabled' }} | ENABLE_DISCORD_NOTIFICATIONS | DISCORD_WEBHOOK_URL |
                  | **Prometheus Integration** | ${{ env.ENABLE_PROMETHEUS_INTEGRATION == 'true' && '‚úÖ Enabled' || '‚ö™ Disabled' }} | ENABLE_PROMETHEUS_INTEGRATION | PROMETHEUS_URL |
                  | **Grafana Integration** | ${{ env.ENABLE_GRAFANA_INTEGRATION == 'true' && '‚úÖ Enabled' || '‚ö™ Disabled' }} | ENABLE_GRAFANA_INTEGRATION | GRAFANA_API_KEY, GRAFANA_URL |
                  | **Custom Webhook** | ${{ env.ENABLE_CUSTOM_WEBHOOK_INTEGRATION == 'true' && '‚úÖ Enabled' || '‚ö™ Disabled' }} | ENABLE_CUSTOM_WEBHOOK_INTEGRATION | CUSTOM_MONITORING_WEBHOOK |

                  ### üîó Setup Links

                  - [üìñ Variables Setup Guide](../../settings/variables/actions)
                  - [üîê Secrets Setup Guide](../../settings/secrets/actions)
                  - [üìä Docker Hub Access Token](https://hub.docker.com/settings/security)
                  - [üì± Slack Webhook Setup](https://api.slack.com/messaging/webhooks)
                  - [üíº Teams Webhook Setup](https://docs.microsoft.com/en-us/microsoftteams/platform/webhooks-and-connectors/how-to/add-incoming-webhook)
                  - [üéÆ Discord Webhook Setup](https://support.discord.com/hc/en-us/articles/228383668-Intro-to-Webhooks)
                  - [üìä Grafana API Key](https://grafana.com/docs/grafana/latest/administration/api-keys/)

                  ### üìä Current Automation Status

                  | Component | Status | Category | Last Activity |
                  |-----------|--------|----------|---------------|
                  | WORKFLOW_STATUS_TABLE |

                  ### üìà Performance Metrics (Last ${{ fromJson(needs.load-configuration.outputs.monitoring_config).history_days }} Days)

                  - **Total Runs**: TOTAL_RUNS
                  - **Success Rate**: SUCCESS_RATE%
                  - **Average Duration**: AVERAGE_DURATION minutes
                  - **Failed Runs**: FAILED_RUNS

                  ### üèóÔ∏è Recent Activity

                  | Workflow | Category | Status | Run # | Time |
                  |----------|----------|--------|-------|------|
                  | RECENT_BUILDS_TABLE |

                  ### üì¶ Container Registry

                  - **Repository**: [`${DOCKER_REPO}`](https://hub.docker.com/r/${DOCKER_REPO})
                  - **Total Pulls**: CONTAINER_PULLS
                  - **Stars**: CONTAINER_STARS
                  - **Last Updated**: CONTAINER_UPDATED

                  ### üéØ Active Issues

                  Current open automation issues: ACTIVE_ISSUES

                  ---

                  ### üîß Quick Actions

                  | Action | Description |
                  |--------|-------------|
                  | [üîÑ Refresh Dashboard](../../actions/workflows/universal-automation-dashboard.yml) | Manually refresh this dashboard |
                  | [üìä View All Workflows](../../actions) | View all workflow runs |
                  | [üêõ Create Issue](../../issues/new) | Report a problem |

                  ### üìã Health Indicators

                  - üü¢ **Healthy**: All systems operational
                  - üü° **Degraded**: Minor issues detected
                  - üî¥ **Unhealthy**: Significant issues requiring attention

                  ---

                  *ü§ñ This dashboard automatically adapts to any project and updates regularly.*

                  *üìä Data source: GitHub Actions API + Container Registry APIs*

                  *‚öôÔ∏è Generated by Universal Automation Dashboard v2.0.0*
                  EOF

            - name: Create or update universal dashboard issue
              uses: actions/github-script@v7
              with:
                  script: |
                      const fs = require('fs');
                      const dashboardContent = fs.readFileSync('dashboard_content.md', 'utf8');
                      const existingIssueNumber = ${{ steps.find_issue.outputs.result }};
                      const dashboardData = JSON.parse('${{ needs.collect-metrics.outputs.dashboard_data }}');

                      const workflowStats = dashboardData.workflow_stats;
                      const containerStats = dashboardData.container_stats;

                      // System health status processing
                      const systemHealthStatus = '${{ needs.collect-metrics.outputs.system_health }}';
                      const healthDisplay = systemHealthStatus === 'healthy' ? 'üü¢ Healthy' : 
                                          systemHealthStatus === 'degraded' ? 'üü° Degraded' : 'üî¥ Unhealthy';

                      console.log(`üìä System health status: ${systemHealthStatus} -> ${healthDisplay}`);

                      // Generate workflow status table
                      let workflowStatusTable = '';
                      Object.entries(workflowStats.workflowCategories).forEach(([category, workflows]) => {
                          if (workflows.length > 0) {
                              const categoryStatus = '‚úÖ Active';
                              const lastActivity = 'Recent';
                              workflowStatusTable += `| ${category.charAt(0).toUpperCase() + category.slice(1)} Workflows | ${categoryStatus} | ${category} | ${lastActivity} |\n`;
                          }
                      });

                      if (!workflowStatusTable) {
                          workflowStatusTable = '| No workflows detected | ‚ö†Ô∏è None | - | - |';
                      }

                      // Generate recent builds table
                      let recentBuildsTable = '';
                      if (workflowStats.recentBuilds && workflowStats.recentBuilds.length > 0) {
                          recentBuildsTable = workflowStats.recentBuilds.slice(0, 10).map(build => {
                              const status = build.status === 'success' ? '‚úÖ' : 
                                          build.status === 'failure' ? '‚ùå' : 
                                          build.status === 'in_progress' ? 'üîÑ' : '‚è∏Ô∏è';

                              const buildTime = new Date(build.created_at);
                              const timeAgo = buildTime.toLocaleDateString('en-US', { 
                                  month: 'short', 
                                  day: 'numeric', 
                                  hour: '2-digit', 
                                  minute: '2-digit' 
                              });

                              return `| ${build.name} | ${build.category} | ${status} ${build.status} | [#${build.run_number}](${build.html_url}) | ${timeAgo} |`;
                          }).join('\n');
                      } else {
                          recentBuildsTable = '| No recent activity | - | - | - | - |';
                      }

                      // Replace all placeholders
                      let updatedContent = dashboardContent
                          .replace('WORKFLOW_STATUS_TABLE', workflowStatusTable)
                          .replace('TOTAL_RUNS', workflowStats.totalRuns || 0)
                          .replace('SUCCESS_RATE', workflowStats.successRate || 0)
                          .replace('AVERAGE_DURATION', workflowStats.averageDuration || 0)
                          .replace('FAILED_RUNS', workflowStats.failedRuns || 0)
                          .replace('RECENT_BUILDS_TABLE', recentBuildsTable)
                          .replace('CONTAINER_PULLS', containerStats.pull_count.toLocaleString())
                          .replace('CONTAINER_STARS', containerStats.star_count)
                          .replace('CONTAINER_UPDATED', containerStats.last_updated)
                          .replace('ACTIVE_ISSUES', dashboardData.active_issues)
                          .replace('SYSTEM_HEALTH_PLACEHOLDER', healthDisplay);

                      console.log('‚úÖ All placeholders replaced successfully');

                      const title = `ü§ñ Automation Dashboard - ${{ env.PROJECT_DISPLAY_NAME || github.repository }}`;

                      if (existingIssueNumber) {
                          await github.rest.issues.update({
                              owner: context.repo.owner,
                              repo: context.repo.repo,
                              issue_number: existingIssueNumber,
                              title: title,
                              body: updatedContent
                          });
                          console.log(`‚úÖ Updated dashboard issue #${existingIssueNumber}`);
                      } else {
                          const newIssue = await github.rest.issues.create({
                              owner: context.repo.owner,
                              repo: context.repo.repo,
                              title: title,
                              body: updatedContent,
                              labels: ['automation-dashboard', 'pinned', 'enhancement']
                          });
                          console.log(`‚úÖ Created new dashboard issue #${newIssue.data.number}`);
                      }

    notify-health-issues:
        needs: [load-configuration, collect-metrics, update-dashboard]
        if: needs.collect-metrics.outputs.system_health != 'healthy' && fromJson(needs.load-configuration.outputs.notification_config).health_alerts
        runs-on: ubuntu-latest

        steps:
            - name: Send configurable notifications to multiple platforms
              if: ${{ fromJson(needs.load-configuration.outputs.notification_config).slack_notifications || fromJson(needs.load-configuration.outputs.notification_config).teams_notifications || fromJson(needs.load-configuration.outputs.notification_config).discord_notifications }}
              env:
                  SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
                  TEAMS_WEBHOOK_URL: ${{ secrets.TEAMS_WEBHOOK_URL }}
                  DISCORD_WEBHOOK_URL: ${{ secrets.DISCORD_WEBHOOK_URL }}
              run: |
                  PROJECT_NAME="${{ env.PROJECT_DISPLAY_NAME || github.repository }}"
                  HEALTH_STATUS="${{ needs.collect-metrics.outputs.system_health }}"

                  # Webhook URL masking for security
                  echo "::add-mask::$SLACK_WEBHOOK_URL"
                  echo "::add-mask::$TEAMS_WEBHOOK_URL"
                  echo "::add-mask::$DISCORD_WEBHOOK_URL"

                  echo "üì¢ Sending health alert notifications to configured platforms..."

                  # Slack notification
                  if [ "${{ fromJson(needs.load-configuration.outputs.notification_config).slack_notifications }}" = "true" ] && [ ! -z "$SLACK_WEBHOOK_URL" ]; then
                      echo "üì± Sending Slack notification..."
                      curl -X POST "$SLACK_WEBHOOK_URL" \
                          -H "Content-Type: application/json" \
                          -d "{
                              \"text\": \"üö® Health Alert: ${PROJECT_NAME}\",
                              \"attachments\": [{
                                  \"color\": \"danger\",
                                  \"fields\": [{
                                      \"title\": \"Status\",
                                      \"value\": \"${HEALTH_STATUS}\",
                                      \"short\": true
                                  }, {
                                      \"title\": \"Repository\",
                                      \"value\": \"${{ github.repository }}\",
                                      \"short\": true
                                  }, {
                                      \"title\": \"Dashboard\",
                                      \"value\": \"<${{ github.server_url }}/${{ github.repository }}/issues?q=is%3Aopen+label%3Aautomation-dashboard|View Dashboard>\",
                                      \"short\": true
                                  }]
                              }]
                          }" && echo "‚úÖ Slack notification sent"
                  fi

                  # Microsoft Teams notification
                  if [ "${{ fromJson(needs.load-configuration.outputs.notification_config).teams_notifications }}" = "true" ] && [ ! -z "$TEAMS_WEBHOOK_URL" ]; then
                      echo "üíº Sending Microsoft Teams notification..."
                      curl -X POST "$TEAMS_WEBHOOK_URL" \
                          -H "Content-Type: application/json" \
                          -d '{
                              "@type": "MessageCard",
                              "@context": "http://schema.org/extensions",
                              "summary": "Health Alert: '"${PROJECT_NAME}"'",
                              "themeColor": "FF0000",
                              "title": "üö® Health Alert",
                              "sections": [{
                                  "activityTitle": "Project: '"${PROJECT_NAME}"'",
                                  "facts": [
                                      {"name": "Status", "value": "'"${HEALTH_STATUS}"'"},
                                      {"name": "Repository", "value": "${{ github.repository }}"},
                                      {"name": "Time", "value": "'"$(date -u +%Y-%m-%dT%H:%M:%SZ)"'"}
                                  ],
                                  "markdown": true
                              }],
                              "potentialAction": [{
                                  "@type": "OpenUri",
                                  "name": "View Dashboard",
                                  "targets": [{
                                      "os": "default",
                                      "uri": "${{ github.server_url }}/${{ github.repository }}/issues?q=is%3Aopen+label%3Aautomation-dashboard"
                                  }]
                              }]
                          }' && echo "‚úÖ Teams notification sent"
                  fi

                  # Discord notification
                  if [ "${{ fromJson(needs.load-configuration.outputs.notification_config).discord_notifications }}" = "true" ] && [ ! -z "$DISCORD_WEBHOOK_URL" ]; then
                      echo "üéÆ Sending Discord notification..."
                      curl -X POST "$DISCORD_WEBHOOK_URL" \
                          -H "Content-Type: application/json" \
                          -d '{
                              "content": "üö® **Health Alert**",
                              "embeds": [{
                                  "title": "'"${PROJECT_NAME}"' - System Health Alert",
                                  "color": 16711680,
                                  "fields": [
                                      {"name": "Status", "value": "'"${HEALTH_STATUS}"'", "inline": true},
                                      {"name": "Repository", "value": "${{ github.repository }}", "inline": true},
                                      {"name": "Time", "value": "'"$(date -u +%Y-%m-%dT%H:%M:%SZ)"'", "inline": true}
                                  ],
                                  "footer": {
                                      "text": "Universal Automation Dashboard"
                                  },
                                  "timestamp": "'"$(date -u +%Y-%m-%dT%H:%M:%SZ)"'"
                              }]
                          }' && echo "‚úÖ Discord notification sent"
                  fi

                  echo "üì¢ Notification delivery completed for all configured platforms"

    close-health-alert-if-healthy:
        needs: [load-configuration, collect-metrics, update-dashboard]
        if: needs.collect-metrics.outputs.system_health == 'healthy'
        runs-on: ubuntu-latest

        steps:
            - name: Close health alert if system recovered
              uses: actions/github-script@v7
              with:
                  script: |
                      const issues = await github.rest.issues.listForRepo({
                          owner: context.repo.owner,
                          repo: context.repo.repo,
                          labels: 'automation-health-alert',
                          state: 'open'
                      });

                      for (const issue of issues.data) {
                          if (issue.title.includes('üö® System Health Alert')) {
                              await github.rest.issues.createComment({
                                  owner: context.repo.owner,
                                  repo: context.repo.repo,
                                  issue_number: issue.number,
                                  body: `## ‚úÖ System Health Recovered!\n\n**Recovery Time**: ${new Date().toISOString()}\n**Status**: üü¢ All systems healthy\n\nAll automation components have returned to normal operation.\n\nThis health monitor will remain closed until new issues are detected.`
                              });

                              await github.rest.issues.update({
                                  owner: context.repo.owner,
                                  repo: context.repo.repo,
                                  issue_number: issue.number,
                                  state: 'closed'
                              });

                              console.log(`Closed health alert issue #${issue.number} - system recovered`);
                          }
                      }
