ARG BASE_IMAGE=ubuntu:24.04

#==============================================
# Build Stage - Ubuntu & Fedora Support
#==============================================
FROM ${BASE_IMAGE} AS fex-builder

ARG TARGETPLATFORM 
ARG ROOTFS_OS=ubuntu
ARG ROOTFS_VERSION="24.04"
ARG LLVM_VERSION=18
ARG CCACHE_DIR=/tmp/.ccache
ARG ENABLE_CCACHE=false

# Set environment variables for non-interactive installation and ccache
ENV DEBIAN_FRONTEND=noninteractive 
ENV TZ=Asia/Seoul
ENV CCACHE_DIR=${CCACHE_DIR}
ENV ENABLE_CCACHE=${ENABLE_CCACHE}

# Detect OS type
RUN echo "ðŸ” Starting OS detection..." && \
    if [ -f /etc/redhat-release ] || [ -f /etc/fedora-release ]; then \
        echo "ðŸ§ Detected: Fedora/RHEL distribution" && \
        echo "DISTRO_TYPE=fedora" > /etc/distro-info; \
    elif [ -f /etc/debian_version ] || [ -f /etc/lsb-release ]; then \
        echo "ðŸ§ Detected: Debian/Ubuntu distribution" && \
        echo "DISTRO_TYPE=debian" > /etc/distro-info && \
        export DEBIAN_FRONTEND=noninteractive && \
        ln -snf /usr/share/zoneinfo/$TZ /etc/localtime && \
        echo $TZ > /etc/timezone; \
    else \
        echo "âŒ Unknown distribution type" && \
        echo "DISTRO_TYPE=unknown" > /etc/distro-info; \
    fi && \
    echo "âœ… OS detection completed"

# Install build dependencies (simplified for Ubuntu 22.04+)
RUN echo "ðŸ“¦ Starting package installation..." && \
    . /etc/distro-info && \
    echo "ðŸ” Distribution type: $(cat /etc/distro-info)" && \
    if [ "$DISTRO_TYPE" = "debian" ]; then \
        echo "ðŸ”§ Setting up Debian/Ubuntu environment..." && \
        apt-get update -qq && \
        echo "ðŸ“¦ Installing development packages..." && \
        apt-get install -qq -y --no-install-recommends \
            git cmake ninja-build pkg-config ccache \
            nasm python3-dev python3-clang python3-setuptools \
            libcap-dev libglfw3-dev libepoxy-dev libsdl2-dev \
            linux-headers-generic curl wget \
            software-properties-common openssl libssl-dev \
            binutils binutils-aarch64-linux-gnu \
            gcc-aarch64-linux-gnu g++-aarch64-linux-gnu \
            qtbase5-dev qtdeclarative5-dev && \
        echo "âœ… Base packages installed successfully" && \
        \
        # Smart LLVM installation with apt-cache check + script fallback
        echo "ðŸ”§ Installing LLVM ${LLVM_VERSION} with smart detection..." && \
        REQUIRED_LLVM_PACKAGES="clang-${LLVM_VERSION} lld-${LLVM_VERSION} llvm-${LLVM_VERSION} llvm-${LLVM_VERSION}-dev llvm-${LLVM_VERSION}-tools" && \
        SYSTEM_LLVM_AVAILABLE=true && \
        echo "ðŸ” Checking system repository for LLVM ${LLVM_VERSION}..." && \
        for pkg in $REQUIRED_LLVM_PACKAGES; do \
            if apt-cache show "$pkg" >/dev/null 2>&1; then \
                echo "âœ… Found system package: $pkg"; \
            else \
                echo "âŒ Missing system package: $pkg" && \
                SYSTEM_LLVM_AVAILABLE=false; \
            fi; \
        done && \
        \
        if [ "$SYSTEM_LLVM_AVAILABLE" = "true" ]; then \
            echo "ðŸŽ¯ Installing LLVM ${LLVM_VERSION} from system repository..." && \
            apt-get install -qq -y \
                clang-${LLVM_VERSION} \
                lld-${LLVM_VERSION} \
                llvm-${LLVM_VERSION} \
                llvm-${LLVM_VERSION}-dev \
                llvm-${LLVM_VERSION}-tools \
                libedit-dev libffi-dev && \
            echo "âœ… LLVM ${LLVM_VERSION} installed from system repository"; \
        else \
            echo "ðŸ”„ Using official LLVM installation script..." && \
            wget --no-cache --no-http-keep-alive -q https://apt.llvm.org/llvm.sh -O llvm.sh && \
            chmod +x llvm.sh && \
            ./llvm.sh ${LLVM_VERSION} >/dev/null 2>&1 && \
            rm llvm.sh && \
            # Verify installation
            if command -v clang-${LLVM_VERSION} >/dev/null 2>&1; then \
                echo "âœ… LLVM ${LLVM_VERSION} installed via official script"; \
            else \
                echo "âŒ LLVM installation failed" && \
                exit 1; \
            fi; \
        fi && \
        \
        # Verify final installation
        echo "ðŸ” Verifying LLVM ${LLVM_VERSION} installation..." && \
        clang-${LLVM_VERSION} --version && \
        echo "âœ… LLVM ${LLVM_VERSION} verification completed" && \
        \
        # Simple cleanup
        echo "ðŸ§¹ Cleaning up..." && \
        update-alternatives --install /usr/bin/lld lld /usr/bin/lld-${LLVM_VERSION} 100 && \
        apt-get autoremove -qq -y && \
        apt-get autoclean -qq && \
        rm -rf /var/lib/apt/lists/* /var/tmp/* && \
        echo "âœ… Debian/Ubuntu setup completed successfully"; \
    elif [ "$DISTRO_TYPE" = "fedora" ]; then \
        echo "ðŸ”§ Setting up Fedora environment..." && \
        dnf update -q -y && \
        echo "ðŸ“¦ Installing Fedora packages..." && \
        dnf install -q -y \
            @development-tools cmake ninja-build pkg-config ccache \
            llvm${LLVM_VERSION} clang${LLVM_VERSION} lld${LLVM_VERSION} \
            compiler-rt${LLVM_VERSION} libomp${LLVM_VERSION} \
            libstdc++-devel libstdc++-static glibc-devel \
            gcc-c++ binutils-devel binutils \
            nasm python3-clang python3-setuptools openssl-devel \
            libcap-devel glfw-devel libepoxy-devel SDL2-devel \
            qt5-qtdeclarative-devel qt5-qtquickcontrols qt5-qtquickcontrols2 \
            curl wget && \
        dnf clean all -q && \
        echo "âœ… Fedora setup completed successfully"; \
    else \
        echo "âŒ Unsupported distribution type" && exit 1; \
    fi && \
    echo "ðŸŽ‰ Package installation completed!"

# Copy ccache binary from build context
COPY --from=ccache-binary . /tmp/ccache-binary

# Simple ccache setup for Ubuntu 22.04+
RUN echo "ðŸ“¦ Setting up ccache..." && \
    echo "ðŸ” System information:" && \
    echo "  - GLIBC version: $(ldd --version | head -1)" && \
    echo "  - Ubuntu version: ${ROOTFS_VERSION}" && \
    echo "  - Architecture: $(uname -m)" && \
    \
    # Simple ccache configuration
    echo "ðŸš€ Enabling system ccache for Ubuntu 22.04+" && \
    echo "CCACHE_SOURCE=system" > /tmp/ccache-info && \
    \
    # Verify system ccache
    if ccache --version >/dev/null 2>&1; then \
        echo "âœ… System ccache working correctly:" && \
        ccache --version; \
    else \
        echo "âš ï¸ System ccache not available, disabling ccache" && \
        echo "CCACHE_SOURCE=disabled" > /tmp/ccache-info; \
    fi && \
    echo "âœ… ccache setup completed"

# Copy FEX source and build (simplified)
COPY --from=fex-sources / /tmp/fex-source  
RUN --mount=type=cache,target=/tmp/.ccache \
    echo "ðŸ—ï¸ Starting FEX build process (Ubuntu 22.04+ optimized)..." && \
    cd /tmp/fex-source && \
    \
    # Check ccache setup
    . /tmp/ccache-info && \
    echo "ðŸ“Š Build environment summary:" && \
    echo "  - ENABLE_CCACHE: ${ENABLE_CCACHE}" && \
    echo "  - CCACHE_SOURCE: ${CCACHE_SOURCE}" && \
    echo "  - LLVM_VERSION: ${LLVM_VERSION}" && \
    echo "  - CCACHE_BINARY: $(which ccache 2>/dev/null || echo 'not found')" && \
    \
    mkdir -p Build && cd Build && \
    \
    # Simple compiler detection
    if command -v clang-${LLVM_VERSION} >/dev/null 2>&1; then \
        CC_COMPILER=clang-${LLVM_VERSION} && \
        CXX_COMPILER=clang++-${LLVM_VERSION}; \
    else \
        CC_COMPILER=clang && \
        CXX_COMPILER=clang++; \
    fi && \
    echo "âœ… Using compilers: $CC_COMPILER / $CXX_COMPILER" && \
    \
    # Simple AR tools detection
    if command -v llvm-ar-${LLVM_VERSION} >/dev/null 2>&1; then \
        AR_TOOL=$(which llvm-ar-${LLVM_VERSION}) && \
        RANLIB_TOOL=$(which llvm-ranlib-${LLVM_VERSION}); \
    else \
        AR_TOOL=$(which ar) && \
        RANLIB_TOOL=$(which ranlib); \
    fi && \
    echo "âœ… Using AR tools: $AR_TOOL" && \
    \
    # Simple ccache configuration
    if [ "${ENABLE_CCACHE:-false}" = "true" ] && [ "${CCACHE_SOURCE}" != "disabled" ]; then \
        echo "ðŸš€ Configuring ccache acceleration..." && \
        export CCACHE_BASEDIR=/tmp/fex-source && \
        export CCACHE_DIR=/tmp/.ccache && \
        export CCACHE_MAXSIZE=2G && \
        export CC="ccache $CC_COMPILER" && \
        export CXX="ccache $CXX_COMPILER" && \
        ccache --zero-stats && \
        echo "âœ… ccache enabled"; \
    else \
        echo "â„¹ï¸ ccache disabled for this build"; \
    fi && \
    \
    # Simple CMake configuration
    echo "âš™ï¸ Running CMake configuration..." && \
    cmake \
        -DCMAKE_INSTALL_PREFIX=/usr/local/fex \
        -DCMAKE_BUILD_TYPE=Release \
        -DUSE_LINKER=lld \
        -DENABLE_LTO=True \
        -DBUILD_TESTS=False \
        -DENABLE_ASSERTIONS=False \
        -DCMAKE_C_COMPILER="$CC_COMPILER" \
        -DCMAKE_CXX_COMPILER="$CXX_COMPILER" \
        -DCMAKE_AR="$AR_TOOL" \
        -DCMAKE_RANLIB="$RANLIB_TOOL" \
        -DCMAKE_C_COMPILER_AR="$AR_TOOL" \
        -DCMAKE_CXX_COMPILER_AR="$AR_TOOL" \
        -G Ninja .. && \
    echo "âœ… CMake configuration completed" && \
    \
    echo "ðŸ”¨ Starting compilation..." && \
    ninja -j$(($(nproc) - 1)) && \
    echo "âœ… Compilation completed successfully" && \
    \
    echo "ðŸ“¦ Installing FEX binaries..." && \
    ninja install && \
    echo "âœ… Installation completed" && \
    \
    # Show ccache statistics if enabled
    if [ "${ENABLE_CCACHE:-false}" = "true" ] && [ "${CCACHE_SOURCE}" != "disabled" ]; then \
        echo "ðŸ“Š ccache Statistics:" && \
        ccache --show-stats; \
    fi && \
    \
    echo "ðŸ§¹ Cleaning up build artifacts..." && \
    rm -rf /tmp/fex-source /tmp/ccache-info /tmp/ccache-binary && \
    echo "ðŸŽ‰ FEX build completed successfully!"

#==============================================
# Runtime Stage - Ubuntu & Fedora Support
#==============================================
FROM ${BASE_IMAGE} AS runtime

ARG TARGETPLATFORM 
ARG ROOTFS_OS=ubuntu
ARG ROOTFS_VERSION="24.04"
ARG ROOTFS_TYPE=squashfs

# Set environment variables for non-interactive installation
ENV DEBIAN_FRONTEND=noninteractive 
ENV TZ=Asia/Seoul

# Detect OS type for runtime
RUN echo "ðŸ” Starting runtime OS detection..." && \
    if [ -f /etc/redhat-release ] || [ -f /etc/fedora-release ]; then \
        echo "ðŸ§ Runtime: Detected Fedora/RHEL distribution" && \
        echo "DISTRO_TYPE=fedora" > /etc/distro-info; \
    elif [ -f /etc/debian_version ] || [ -f /etc/lsb-release ]; then \
        echo "ðŸ§ Runtime: Detected Debian/Ubuntu distribution" && \
        echo "DISTRO_TYPE=debian" > /etc/distro-info && \
        export DEBIAN_FRONTEND=noninteractive && \
        ln -snf /usr/share/zoneinfo/$TZ /etc/localtime && \
        echo $TZ > /etc/timezone; \
    else \
        echo "âŒ Runtime: Unknown distribution type" && \
        echo "DISTRO_TYPE=unknown" > /etc/distro-info; \
    fi && \
    echo "âœ… Runtime OS detection completed"

# Install runtime dependencies (simplified)
RUN echo "ðŸ“¦ Starting runtime dependencies installation..." && \
    . /etc/distro-info && \
    echo "ðŸ“Š Runtime build parameters:" && \
    echo "  - ROOTFS_OS: ${ROOTFS_OS}" && \
    echo "  - ROOTFS_VERSION: ${ROOTFS_VERSION}" && \
    echo "  - ROOTFS_TYPE: ${ROOTFS_TYPE}" && \
    if [ "$DISTRO_TYPE" = "debian" ]; then \
        echo "ðŸ”§ Setting up Debian/Ubuntu runtime environment..." && \
        apt-get update -qq && \
        echo "ðŸ“¦ Installing minimal runtime packages..." && \
        apt-get install -qq -y --no-install-recommends \
            squashfs-tools squashfuse sudo curl wget jq \
            libstdc++6 libc6 && \
        echo "âœ… Runtime packages installed" && \
        \
        # Cleanup for size optimization
        echo "ðŸ§¹ Performing cleanup for size optimization..." && \
        apt-get autoremove -y && \
        apt-get autoclean && \
        rm -rf /var/lib/apt/lists/* /var/tmp/* /var/cache/* && \
        echo "âœ… Debian/Ubuntu runtime setup completed successfully"; \
    elif [ "$DISTRO_TYPE" = "fedora" ]; then \
        echo "ðŸ”§ Setting up Fedora runtime environment..." && \
        echo "ðŸ“¦ Installing minimal Fedora runtime packages..." && \
        dnf install -q -y --setopt=install_weak_deps=False \
            squashfs-tools squashfuse erofs-fuse erofs-utils curl wget jq \
            sudo util-linux-core libstdc++ glibc && \
        echo "âœ… Fedora runtime packages installed" && \
        echo "ðŸ§¹ Cleaning up Fedora package cache..." && \
        dnf clean all -q && \
        rm -rf /var/cache/dnf /var/tmp/* && \
        echo "âœ… Fedora runtime setup completed successfully"; \
    else \
        echo "âŒ Unsupported distribution type for runtime" && exit 1; \
    fi && \
    echo "ðŸŽ‰ Runtime dependencies installation completed!"

# Copy FEX binaries from build stage and optimize
COPY --from=fex-builder /usr/local/fex /usr/local/fex
RUN echo "âœ… FEX binaries copied successfully" && \
    echo "ðŸ“Š FEX installation summary:" && \
    ls -la /usr/local/fex/bin/ && \
    echo "ðŸ”§ Optimizing FEX binaries..." && \
    strip /usr/local/fex/bin/* 2>/dev/null || true && \
    find /usr/local/fex -name "*.so*" -exec strip --strip-unneeded {} + 2>/dev/null || true && \
    echo "âœ… FEX binary optimization completed"
ENV PATH="/usr/local/fex/bin:$PATH"

# Create user with OS-specific configuration (MOVED BEFORE ROOTFS setup)
RUN echo "ðŸ‘¤ Starting user creation and configuration..." && \
    . /etc/distro-info && \
    useradd -m -s /bin/bash fex && \
    echo "âœ… User 'fex' created successfully" && \
    if [ "$DISTRO_TYPE" = "debian" ]; then \
        usermod -aG sudo fex; \
    elif [ "$DISTRO_TYPE" = "fedora" ]; then \
        usermod -aG wheel fex; \
    fi && \
    echo "fex ALL=(ALL) NOPASSWD: ALL" > /etc/sudoers.d/fex && \
    echo "âœ… User configuration completed"

# Setup RootFS using FEXRootFSFetcher FIRST, manual fallback
RUN echo "ðŸš€ Starting RootFS setup process..." && \
    echo "ðŸ“Š RootFS configuration:" && \
    echo "  - Target OS: ${ROOTFS_OS}" && \
    echo "  - Target Version: ${ROOTFS_VERSION}" && \
    echo "  - RootFS Type: ${ROOTFS_TYPE}" && \
    \
    # Create user first (FEXRootFSFetcher is per-user install)
    useradd -m -s /bin/bash fex 2>/dev/null || true && \
    \
    # Test FEX RootFS API connectivity to determine primary method
    echo "ðŸ” Testing FEX RootFS API connectivity..." && \
    curl -H 'Cache-Control: no-cache, no-store' -s --connect-timeout 10 https://rootfs.fex-emu.gg/RootFS_links.json >/dev/null 2>&1 && \
    API_TEST_RESULT=$? && \
    \
    if [ $API_TEST_RESULT -eq 0 ]; then \
        echo "âœ… FEX RootFS API accessible - attempting FEXRootFSFetcher (PRIMARY METHOD)" && \
        \
        # PRIMARY: FEXRootFSFetcher with retry logic
        echo "ðŸ“¥ Starting FEXRootFSFetcher (official recommended method)..." && \
        FEXROOTFS_SUCCESS=false && \
        for attempt in 1 2 3; do \
            echo "â³ FEXRootFSFetcher attempt $attempt/3..." && \
            if timeout 300 sudo -u fex FEXRootFSFetcher -yx --distro-name=${ROOTFS_OS} --distro-version=${ROOTFS_VERSION} --force-ui=tty 2>/dev/null; then \
                echo "âœ… FEXRootFSFetcher completed successfully (attempt $attempt)" && \
                FEXROOTFS_SUCCESS=true && \
                break; \
            else \
                echo "âŒ FEXRootFSFetcher failed (attempt $attempt)" && \
                if [ $attempt -lt 3 ]; then \
                    echo "â³ Waiting 30 seconds before retry..." && \
                    sleep 30; \
                fi; \
            fi; \
        done; \
    else \
        echo "âŒ FEX RootFS API not accessible - FEXRootFSFetcher will not work" && \
        FEXROOTFS_SUCCESS=false; \
    fi && \
    \
    # FALLBACK: Manual setup if FEXRootFSFetcher failed or API unavailable
    if [ "$FEXROOTFS_SUCCESS" = "false" ]; then \
        echo "ðŸ”„ FEXRootFSFetcher failed or unavailable - falling back to manual setup..." && \
        \
        # Create necessary directories for manual setup
        mkdir -p /home/fex/.fex-emu/RootFS && \
        \
        # Download RootFS JSON with enhanced fallback
        echo "ðŸ“¥ Downloading RootFS links from FEX server (manual method)..." && \
        ROOTFS_JSON_URL="https://rootfs.fex-emu.gg/RootFS_links.json" && \
        ROOTFS_JSON="/tmp/rootfs_links.json" && \
        JSON_DOWNLOAD_SUCCESS=false && \
        \
        # Try wget first (execute outside if statement)
        echo "ðŸ”„ Attempting JSON download via wget..." && \
        wget --no-cache --no-http-keep-alive -q --timeout=30 -O "$ROOTFS_JSON" "$ROOTFS_JSON_URL" >/dev/null 2>&1 && \
        WGET_EXIT_CODE=$? && \
        if [ $WGET_EXIT_CODE -eq 0 ]; then \
            echo "âœ… RootFS JSON downloaded successfully via wget" && \
            JSON_DOWNLOAD_SUCCESS=true; \
        else \
            echo "ðŸ”„ wget failed, trying curl..." && \
            curl -H 'Cache-Control: no-cache, no-store' -s --connect-timeout 30 "$ROOTFS_JSON_URL" -o "$ROOTFS_JSON" >/dev/null 2>&1 && \
            CURL_EXIT_CODE=$? && \
            if [ $CURL_EXIT_CODE -eq 0 ]; then \
                echo "âœ… RootFS JSON downloaded successfully via curl" && \
                JSON_DOWNLOAD_SUCCESS=true; \
            fi; \
        fi && \
        \
        # Ultimate fallback: embedded JSON
        if [ "$JSON_DOWNLOAD_SUCCESS" = "false" ]; then \
            echo "âš ï¸ All download methods failed, using embedded fallback JSON..." && \
            echo '{"v1":{"Fedora 40 (SquashFS)":{"DistroMatch":"fedora","DistroVersion":"40","URL":"https://rootfs.fex-emu.gg/Fedora_40/2025-01-08/Fedora_40.sqsh","Hash":"fb51fcd7f086fa19","Type":"squashfs"},"Ubuntu 24.04 (SquashFS)":{"DistroMatch":"ubuntu","DistroVersion":"24.04","URL":"https://rootfs.fex-emu.gg/Ubuntu_24_04/2025-03-04/Ubuntu_24_04.sqsh","Hash":"6d469a5d2bb838ac","Type":"squashfs"},"Ubuntu 22.04 (SquashFS)":{"DistroMatch":"ubuntu","DistroVersion":"22.04","URL":"https://rootfs.fex-emu.gg/Ubuntu_22_04/2025-01-08/Ubuntu_22_04.sqsh","Hash":"73c9269e4c4ca172","Type":"squashfs"}}}' > "$ROOTFS_JSON" && \
            echo "âœ… Embedded fallback JSON created" && \
            JSON_DOWNLOAD_SUCCESS=true; \
        fi && \
        \
        # Parse JSON to find matching OS and version
        echo "ðŸ” Searching for ${ROOTFS_OS} ${ROOTFS_VERSION} in RootFS list..." && \
        MATCHED_ENTRY=$(cat "$ROOTFS_JSON" | jq -r --arg os "$ROOTFS_OS" --arg version "$ROOTFS_VERSION" \
            '.v1 | to_entries[] | select(.value.DistroMatch == $os and .value.DistroVersion == $version and .value.Type == "squashfs") | .value') && \
        \
        if [ -n "$MATCHED_ENTRY" ] && [ "$MATCHED_ENTRY" != "null" ]; then \
            ROOTFS_URL=$(echo "$MATCHED_ENTRY" | jq -r '.URL') && \
            ROOTFS_FILENAME=$(basename "$ROOTFS_URL") && \
            ROOTFS_TYPE=$(echo "$MATCHED_ENTRY" | jq -r '.Type') && \
            echo "âœ… Found matching RootFS:" && \
            echo "  - URL: $ROOTFS_URL" && \
            echo "  - Filename: $ROOTFS_FILENAME" && \
            echo "  - Type: $ROOTFS_TYPE"; \
        else \
            echo "âŒ No matching RootFS found for ${ROOTFS_OS} ${ROOTFS_VERSION}" && \
            echo "ðŸ“‹ Available RootFS options:" && \
            cat "$ROOTFS_JSON" | jq -r '.v1 | to_entries[] | "  - \(.value.DistroMatch) \(.value.DistroVersion) (\(.value.Type))"' && \
            exit 1; \
        fi && \
        \
        # Download RootFS file (execute outside if statement)
        echo "ðŸ“¥ Downloading RootFS file: $ROOTFS_FILENAME..." && \
        ROOTFS_LOCAL_PATH="/tmp/$ROOTFS_FILENAME" && \
        FILE_DOWNLOAD_SUCCESS=false && \
        \
        # Try curl first
        echo "ðŸ”„ Attempting file download via curl..." && \
        curl -H 'Cache-Control: no-cache, no-store' -L --progress-bar --connect-timeout 30 --max-time 600 "$ROOTFS_URL" -o "$ROOTFS_LOCAL_PATH" >/dev/null 2>&1 && \
        CURL_FILE_EXIT_CODE=$? && \
        if [ $CURL_FILE_EXIT_CODE -eq 0 ]; then \
            echo "âœ… RootFS file downloaded successfully via curl" && \
            FILE_DOWNLOAD_SUCCESS=true; \
        else \
            echo "ðŸ”„ curl failed, trying wget..." && \
            wget --no-cache --no-http-keep-alive -q --timeout=60 --tries=3 --retry-connrefused -O "$ROOTFS_LOCAL_PATH" "$ROOTFS_URL" >/dev/null 2>&1 && \
            WGET_FILE_EXIT_CODE=$? && \
            if [ $WGET_FILE_EXIT_CODE -eq 0 ]; then \
                echo "âœ… RootFS file downloaded successfully via wget" && \
                FILE_DOWNLOAD_SUCCESS=true; \
            fi; \
        fi && \
        \
        # Check download success
        if [ "$FILE_DOWNLOAD_SUCCESS" = "false" ]; then \
            echo "âŒ Failed to download RootFS file with both curl and wget" && \
            exit 1; \
        fi && \
        \
        # Extract RootFS based on file type
        echo "ðŸ“¦ Extracting RootFS..." && \
        ROOTFS_DIRNAME="$(echo ${ROOTFS_OS} | sed 's/^./\U&/')_$(echo ${ROOTFS_VERSION} | sed 's/\./_/g')" && \
        EXTRACT_DIR="/home/fex/.fex-emu/RootFS/${ROOTFS_DIRNAME}" && \
        echo "ðŸ“‹ RootFS directory name: $ROOTFS_DIRNAME" && \
        \
        if [ -d "$EXTRACT_DIR" ]; then \
            echo "ðŸ—‘ï¸ Removing existing RootFS directory..." && \
            rm -rf "$EXTRACT_DIR"; \
        fi && \
        mkdir -p "$EXTRACT_DIR" && \
        \
        if echo "$ROOTFS_FILENAME" | grep -q '\.sqsh$\|\.squashfs$'; then \
            echo "ðŸ”§ Extracting SquashFS file using unsquashfs..." && \
            if command -v unsquashfs >/dev/null 2>&1; then \
                cd /tmp && \
                unsquashfs -f -d "$EXTRACT_DIR" "$ROOTFS_LOCAL_PATH" && \
                echo "âœ… SquashFS extraction completed"; \
            else \
                echo "âŒ unsquashfs not found. Installing squashfs-tools..." && \
                apt-get update -qq && apt-get install -y --no-install-recommends squashfs-tools && \
                unsquashfs -f -d "$EXTRACT_DIR" "$ROOTFS_LOCAL_PATH" && \
                echo "âœ… SquashFS extraction completed"; \
            fi; \
        elif echo "$ROOTFS_FILENAME" | grep -q '\.ero$\|\.erofs$'; then \
            echo "ðŸ”§ Extracting EROFS file..." && \
            if ! command -v dump.erofs >/dev/null 2>&1; then \
                echo "ðŸ“¦ Installing erofs-utils..." && \
                apt-get update -qq && \
                apt-get install -y --no-install-recommends erofs-utils; \
            fi && \
            dump.erofs --extract="$EXTRACT_DIR" "$ROOTFS_LOCAL_PATH" && \
            echo "âœ… EROFS extraction completed"; \
        else \
            echo "âŒ Unknown RootFS file format: $ROOTFS_FILENAME" && \
            exit 1; \
        fi && \
        \
        # Create FEX configuration with correct format
        echo "âš™ï¸ Writing FEX configuration..." && \
        CONFIG_PATH="/home/fex/.fex-emu/Config.json" && \
        printf '{"Config":{"RootFS":"%s"},"ThunksDB":{}}' "$ROOTFS_DIRNAME" > "$CONFIG_PATH" && \
        echo "âœ… FEX configuration written to $CONFIG_PATH" && \
        \
        # Set proper ownership for manual setup
        chown -R fex:fex /home/fex/.fex-emu && \
        \
        # Verify manual installation
        echo "ðŸ” Verifying manual RootFS installation..." && \
        if [ -d "$EXTRACT_DIR" ]; then \
            ROOTFS_CONTENT_COUNT=$(find "$EXTRACT_DIR" -type f | wc -l) && \
            echo "ðŸ“Š Manual RootFS verification results:" && \
            echo "  - Directory: $EXTRACT_DIR" && \
            echo "  - Files: $ROOTFS_CONTENT_COUNT" && \
            \
            if [ "$ROOTFS_CONTENT_COUNT" -gt 100 ]; then \
                echo "âœ… Manual RootFS appears to be properly extracted"; \
            else \
                echo "âš ï¸ Manual RootFS may be incomplete (too few files)"; \
            fi; \
        else \
            echo "âŒ Manual RootFS directory not found after extraction" && \
            exit 1; \
        fi && \
        \
        # Cleanup temporary files
        echo "ðŸ§¹ Cleaning up manual setup temporary files..." && \
        rm -f "$ROOTFS_LOCAL_PATH" "$ROOTFS_JSON" && \
        \
        echo "ðŸŽ‰ Manual RootFS setup completed successfully as fallback!"; \
    else \
        echo "ðŸŽ‰ FEXRootFSFetcher setup completed successfully!" && \
        # Set proper ownership for FEXRootFSFetcher result
        chown -R fex:fex /home/fex/.fex-emu; \
    fi && \
    \
    # Final verification for both methods
    echo "ðŸ”§ Final RootFS verification..." && \
    if [ -d "/home/fex/.fex-emu/RootFS" ]; then \
        ROOTFS_COUNT=$(find /home/fex/.fex-emu/RootFS -maxdepth 1 -type d | wc -l) && \
        ROOTFS_FILES=$(find /home/fex/.fex-emu/RootFS -type f | wc -l) && \
        echo "ðŸ“Š Final RootFS verification:" && \
        echo "  - RootFS directories: $ROOTFS_COUNT" && \
        echo "  - RootFS files: $ROOTFS_FILES" && \
        echo "  - Method used: $([ "$FEXROOTFS_SUCCESS" = "true" ] && echo "FEXRootFSFetcher (primary)" || echo "Manual setup (fallback)")" && \
        \
        if [ "$ROOTFS_FILES" -gt 0 ]; then \
            echo "âœ… Final RootFS verification passed"; \
        else \
            echo "âŒ Final RootFS verification failed - no files found" && \
            exit 1; \
        fi; \
    else \
        echo "âŒ RootFS directory not found" && \
        exit 1; \
    fi && \
    \
    # Cleanup downloaded artifacts but keep RootFS
    echo "ðŸ§¹ Cleaning up temporary RootFS artifacts..." && \
    find /home/fex/.fex-emu/RootFS -name "*.sqsh" -delete 2>/dev/null || true && \
    find /home/fex/.fex-emu/RootFS -name "*.ero" -delete 2>/dev/null || true && \
    echo "ðŸ’¾ Final RootFS size: $(du -sh /home/fex/.fex-emu/ 2>/dev/null || echo 'unknown')" && \
    echo "ðŸŽ‰ RootFS setup completed successfully!"

# Switch to fex user
USER fex
WORKDIR /home/fex

ENTRYPOINT ["/bin/bash", "-c"]
CMD ["/bin/bash"]
